{
  "version": 3,
  "sources": ["../../@yaireo/tagify/dist/src/parts/constants.js", "../../@yaireo/tagify/dist/src/parts/helpers.js", "../../@yaireo/tagify/dist/src/parts/defaults.js", "../../@yaireo/tagify/dist/src/parts/dropdown.js", "../../@yaireo/tagify/dist/src/parts/suggestions.js", "../../@yaireo/tagify/dist/src/parts/persist.js", "../../@yaireo/tagify/dist/src/parts/texts.js", "../../@yaireo/tagify/dist/src/parts/templates.js", "../../@yaireo/tagify/dist/src/parts/events.js", "../../@yaireo/tagify/dist/src/tagify.js", "../../@yaireo/tagify/dist/src/parts/EventDispatcher.js"],
  "sourcesContent": ["export var ZERO_WIDTH_CHAR = '\\u200B';\nexport var ZERO_WIDTH_UNICODE_CHAR = `&#8203;`", "import {ZERO_WIDTH_CHAR} from './constants'\n\nexport const logger = {\n    isEnabled() { return window.TAGIFY_DEBUG ?? true},\n    log(...args){ this.isEnabled() && console.log('[Tagify]:', ...args) },\n    warn(...args) { this.isEnabled() && console.warn('[Tagify]:', ...args) }\n}\n\n// console.json = console.json || function(argument){\n//     for(var arg=0; arg < arguments.length; ++arg)\n//         console.log(  JSON.stringify(arguments[arg], null, 4)  )\n// }\n\n// const isEdge = /Edge/.test(navigator.userAgent)\nexport const sameStr = (s1, s2, caseSensitive, trim) => {\n    // cast to String\n    s1 = \"\"+s1;\n    s2 = \"\"+s2;\n\n    if( trim ){\n        s1 = s1.trim()\n        s2 = s2.trim()\n    }\n\n    return caseSensitive\n        ? s1 == s2\n        : s1.toLowerCase() == s2.toLowerCase()\n}\n\n\n// const getUID = () => (new Date().getTime() + Math.floor((Math.random()*10000)+1)).toString(16)\nexport const removeCollectionProp = (collection, unwantedProps) => collection && Array.isArray(collection) && collection.map(v => omit(v, unwantedProps))\n\nexport function omit(obj, props){\n    var newObj = {}, p;\n    for( p in obj )\n        if( props.indexOf(p) < 0 )\n            newObj[p] = obj[p]\n    return newObj\n}\n\nexport function decode( s ) {\n    var el = document.createElement('div');\n    return s.replace(/\\&#?[0-9a-z]+;/gi, function(enc){\n        el.innerHTML = enc;\n        return el.innerText\n    })\n}\n\n/**\n * utility method\n * https://stackoverflow.com/a/35385518/104380\n * @param  {String} s [HTML string]\n * @return {Object}   [DOM node]\n */\nexport function parseHTML( s ){\n    var parser = new DOMParser(),\n        node   = parser.parseFromString(s.trim(), \"text/html\");\n\n    return node.body.firstElementChild;\n}\n\n/**\n * Removed new lines and irrelevant spaces which might affect layout, and are better gone\n * @param {string} s [HTML string]\n */\nexport function minify( s ){\n    return s ? s\n        .replace(/\\>[\\r\\n ]+\\</g, \"><\")\n        .split(/>\\s+</).join('><').trim()\n        : \"\"\n}\n\nexport function removeTextChildNodes( elm ){\n    var iter = document.createNodeIterator(elm, NodeFilter.SHOW_TEXT, null, false),\n        textnode;\n\n    // print all text nodes\n    while (textnode = iter.nextNode()){\n        if( !textnode.textContent.trim() )\n            textnode.parentNode.removeChild(textnode)\n    }\n}\n\nexport function getfirstTextNode( elm, action ){\n    action = action || 'previous';\n    while ( elm = elm[action + 'Sibling'] )\n        if( elm.nodeType == 3 )\n            return elm\n}\n\n/**\n * utility method\n * https://stackoverflow.com/a/6234804/104380\n */\nexport function escapeHTML( s ){\n    return typeof s == 'string' ? s\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/`|'/g, \"&#039;\")\n        : s;\n}\n\n/**\n * Checks if an argument is a javascript Object\n */\nexport function isObject(obj) {\n    var type = Object.prototype.toString.call(obj).split(' ')[1].slice(0, -1);\n    return obj === Object(obj) && type != 'Array' && type != 'Function' && type != 'RegExp' && type != 'HTMLUnknownElement';\n}\n\n/**\n * merge objects into a single new one\n * TEST: extend({}, {a:{foo:1}, b:[]}, {a:{bar:2}, b:[1], c:()=>{}})\n */\nexport function extend( o, o1, o2) {\n    if( !(o instanceof Object) ) o = {};\n\n    copy(o, o1);\n    if( o2 )\n        copy(o, o2)\n\n    function copy(a,b){\n        // copy o2 to o\n        for( var key in b )\n            if( b.hasOwnProperty(key) ){\n                if( isObject(b[key]) ){\n                    if( !isObject(a[key]) )\n                        a[key] = Object.assign({}, b[key])\n                    else\n                        copy(a[key], b[key])\n\n                    continue;\n                }\n\n                if( Array.isArray(b[key]) ){\n                    a[key] = Object.assign([], b[key])\n                    continue\n                }\n\n                a[key] = b[key]\n            }\n    }\n\n    return o\n}\n\n/**\n * concatenates N arrays without dups.\n * If an array's item is an Object, compare by `value`\n */\nexport function concatWithoutDups(){\n    const newArr = [],\n        existingObj = {};\n\n    for( let arr of arguments ) {\n        for( let item of arr ) {\n            // if current item is an object which has yet to be added to the new array\n            if( isObject(item) ){\n                if( !existingObj[item.value] ){\n                    newArr.push(item)\n                    existingObj[item.value] = 1\n                }\n            }\n\n            // if current item is not an object and is not in the new array\n            else if( !newArr.includes(item) )\n                newArr.push(item)\n        }\n    }\n\n    return newArr\n}\n\n/**\n *  Extracted from: https://stackoverflow.com/a/37511463/104380\n * @param {String} s\n */\nexport function unaccent( s ){\n    // if not supported, do not continue.\n    // developers should use a polyfill:\n    // https://github.com/walling/unorm\n    if( !String.prototype.normalize )\n        return s\n\n    if (typeof(s) === 'string')\n        return s.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\")\n}\n\n/**\n * Meassures an element's height, which might yet have been added DOM\n * https://stackoverflow.com/q/5944038/104380\n * @param {DOM} node\n */\nexport function getNodeHeight( node ){\n    var height, clone = node.cloneNode(true)\n    clone.style.cssText = \"position:fixed; top:-9999px; opacity:0\"\n    document.body.appendChild(clone)\n    height = clone.clientHeight\n    clone.parentNode.removeChild(clone)\n    return height\n}\n\nexport var isChromeAndroidBrowser = () => /(?=.*chrome)(?=.*android)/i.test(navigator.userAgent)\n\nexport function getUID() {\n    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>\n        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n    )\n}\n\nexport function isNodeTag(node){\n    return isNodeBelongsToThisTagifyInstance.call(this, node) && node?.classList?.contains(this.settings.classNames.tag)\n}\n\nexport function isWithinNodeTag(node){\n    return isNodeBelongsToThisTagifyInstance.call(this, node) && node?.closest(this.settings.classNames.tagSelector)\n}\n\nfunction isNodeBelongsToThisTagifyInstance(node) {\n    let closestTagifyNode = node?.closest(this.settings.classNames.namespaceSelector)\n    return closestTagifyNode === this.DOM.scope\n}\n\n/**\n* Get the caret position relative to the viewport\n* https://stackoverflow.com/q/58985076/104380\n*\n* @returns {object} left, top distance in pixels\n*/\nexport function getCaretGlobalPosition(){\n   const sel = document.getSelection()\n\n   if( sel.rangeCount ){\n       const r = sel.getRangeAt(0)\n       const node = r.startContainer\n       const offset = r.startOffset\n       let rect,  r2;\n\n       if (offset > 0) {\n           r2 = document.createRange()\n           r2.setStart(node, offset - 1)\n           r2.setEnd(node, offset)\n           rect = r2.getBoundingClientRect()\n           return {left:rect.right, top:rect.top, bottom:rect.bottom}\n       }\n\n       if( node.getBoundingClientRect )\n           return node.getBoundingClientRect()\n   }\n\n   return {left:-9999, top:-9999}\n}\n\n/**\n * Injects content (either string or node) at the current the current (or specificed) caret position\n * @param {content} string/node\n * @param {range} Object (optional, a range other than the current window selection)\n */\nexport function injectAtCaret(content, range){\n    var selection = window.getSelection();\n    range = range || selection.getRangeAt(0)\n\n    if( typeof content == 'string' )\n        content = document.createTextNode(content)\n\n    if( range ) {\n        range.deleteContents()\n        range.insertNode(content)\n    }\n\n    return content\n}\n\n/** Setter/Getter\n * Each tag DOM node contains a custom property called \"__tagifyTagData\" which hosts its data\n * @param {Node}   tagElm\n * @param {Object} data\n */\nexport function getSetTagData(tagElm, data, override){\n    if( !tagElm ){\n        logger.warn(\"tag element doesn't exist\",{tagElm, data})\n        return data\n    }\n\n    if( data )\n        tagElm.__tagifyTagData = override\n            ? data\n            : extend({}, tagElm.__tagifyTagData || {}, data)\n\n    return tagElm.__tagifyTagData\n}\n\nexport function placeCaretAfterNode( node ){\n    if( !node || !node.parentNode ) return\n\n    var nextSibling = node,\n        sel = window.getSelection(),\n        range = sel.getRangeAt(0);\n\n    if (sel.rangeCount) {\n        range.setStartAfter(nextSibling);\n        range.collapse(true)\n        // range.setEndBefore(nextSibling || node);\n        sel.removeAllRanges();\n        sel.addRange(range);\n    }\n}\n\n/**\n * iterate all tags, checking if multiple ones are close-siblings and if so, add a zero-space width character between them,\n * which forces the caret to be rendered when the selection is between tags.\n * Also do that if the tag is the first node.\n * @param {Array} tags\n */\nexport function fixCaretBetweenTags(tags, TagifyHasFocuse) {\n    tags.forEach(tag => {\n        if( getSetTagData(tag.previousSibling) || !tag.previousSibling ) {\n            var textNode = document.createTextNode(ZERO_WIDTH_CHAR)\n            tag.before(textNode)\n            TagifyHasFocuse && placeCaretAfterNode(textNode)\n        }\n    })\n}\n\n", "export default {\r\n    delimiters          : \",\",            // [RegEx] split tags by any of these delimiters (\"null\" to cancel) Example: \",| |.\"\r\n    pattern             : null,           // RegEx pattern to validate input by. Ex: /[1-9]/\r\n    tagTextProp         : 'value',        // tag data Object property which will be displayed as the tag's text\r\n    maxTags             : Infinity,       // Maximum number of tags\r\n    callbacks           : {},             // Exposed callbacks object to be triggered on certain events\r\n    addTagOnBlur        : true,           // automatically adds the text which was inputed as a tag when blur event happens\r\n    addTagOn            : ['blur', 'tab', 'enter'],  // if the tagify field (in a normal mode) has any non-tag input in it, convert it to a tag on any of these events: blur away from the field, click \"tab\"/\"enter\" key\r\n    onChangeAfterBlur   : true,           // By default, the native way of inputs' onChange events is kept, and it only fires when the field is blured.\r\n    duplicates          : false,          // \"true\" - allow duplicate tags\r\n    whitelist           : [],             // Array of tags to suggest as the user types (can be used along with \"enforceWhitelist\" setting)\r\n    blacklist           : [],             // A list of non-allowed tags\r\n    enforceWhitelist    : false,          // Only allow tags from the whitelist\r\n    userInput           : true,           // disable manually typing/pasting/editing tags (tags may only be added from the whitelist)\r\n    focusable           : true,           // Allow the component as a whole to recieve focus. There are implementations of Tagify without external border and so 'focusability' causes unwanted behaviour\r\n    keepInvalidTags     : false,          // if true, do not remove tags which did not pass validation\r\n    createInvalidTags   : true,           // if false, do not create invalid tags from invalid user input\r\n    mixTagsAllowedAfter : /,|\\.|\\:|\\s/,   // RegEx - Define conditions in which mix-tags content allows a tag to be added after\r\n    mixTagsInterpolator : ['[[', ']]'],   // Interpolation for mix mode. Everything between these will become a tag, if is a valid Object\r\n    backspace           : true,           // false / true / \"edit\"\r\n    skipInvalid         : false,          // If `true`, do not add invalid, temporary, tags before automatically removing them\r\n    pasteAsTags         : true,           // automatically converts pasted text into tags. if \"false\", allows for further text editing\r\n\r\n    editTags            : {\r\n        clicks      : 2,                  // clicks to enter \"edit-mode\": 1 for single click. any other value is considered as double-click\r\n        keepInvalid : true                // keeps invalid edits as-is until `esc` is pressed while in focus\r\n    },              // 1 or 2 clicks to edit a tag. false/null for not allowing editing\r\n    transformTag        : ()=>{},         // Takes a tag input string as argument and returns a transformed value\r\n    trim                : true,           // whether or not the value provided should be trimmed, before being added as a tag\r\n    a11y: {\r\n        focusableTags: false\r\n    },\r\n\r\n    mixMode: {\r\n        insertAfterTag  : '\\u00A0',       // String/Node to inject after a tag has been added (see #588)\r\n    },\r\n\r\n    autoComplete: {\r\n        enabled: true,        // Tries to suggest the input's value while typing (match from whitelist) by adding the rest of term as grayed-out text\r\n        rightKey: false,      // If `true`, when Right key is pressed, use the suggested value to create a tag, else just auto-completes the input. in mixed-mode this is set to \"true\"\r\n        tabKey: false,        // If 'true`, pressing `tab` key would only auto-complete but not also convert to a tag (like `rightKey` does).\r\n    },\r\n\r\n    classNames: {\r\n        namespace            : 'tagify',\r\n        mixMode              : 'tagify--mix',\r\n        selectMode           : 'tagify--select',\r\n        input                : 'tagify__input',\r\n        focus                : 'tagify--focus',\r\n        tagNoAnimation       : 'tagify--noAnim',\r\n        tagInvalid           : 'tagify--invalid',\r\n        tagNotAllowed        : 'tagify--notAllowed',\r\n        scopeLoading         : 'tagify--loading',\r\n        hasMaxTags           : 'tagify--hasMaxTags',\r\n        hasNoTags            : 'tagify--noTags',\r\n        empty                : 'tagify--empty',\r\n        inputInvalid         : 'tagify__input--invalid',\r\n        dropdown             : 'tagify__dropdown',\r\n        dropdownWrapper      : 'tagify__dropdown__wrapper',\r\n        dropdownHeader       : 'tagify__dropdown__header',\r\n        dropdownFooter       : 'tagify__dropdown__footer',\r\n        dropdownItem         : 'tagify__dropdown__item',\r\n        dropdownItemActive   : 'tagify__dropdown__item--active',\r\n        dropdownItemHidden   : 'tagify__dropdown__item--hidden',\r\n        dropdownItemSelected : 'tagify__dropdown__item--selected',\r\n        dropdownInital       : 'tagify__dropdown--initial',\r\n        tag                  : 'tagify__tag',\r\n        tagText              : 'tagify__tag-text',\r\n        tagX                 : 'tagify__tag__removeBtn',\r\n        tagLoading           : 'tagify__tag--loading',\r\n        tagEditing           : 'tagify__tag--editable',\r\n        tagFlash             : 'tagify__tag--flash',\r\n        tagHide              : 'tagify__tag--hide',\r\n\r\n    },\r\n\r\n    dropdown: {\r\n        classname          : '',\r\n        enabled            : 2,      // minimum input characters to be typed for the suggestions dropdown to show\r\n        maxItems           : 10,\r\n        searchKeys         : [\"value\", \"searchBy\"],\r\n        fuzzySearch        : true,\r\n        caseSensitive      : false,\r\n        accentedSearch     : true,\r\n        includeSelectedTags: false,  // Should the suggestions list Include already-selected tags (after filtering)\r\n        escapeHTML         : true,   // escapes HTML entities in the suggestions' rendered text\r\n        highlightFirst     : true,   // highlights first-matched item in the list\r\n        closeOnSelect      : true,   // closes the dropdown after selecting an item, if `enabled:0` (which means always show dropdown)\r\n        clearOnSelect      : true,   // after selecting a suggetion, should the typed text input remain or be cleared\r\n        position           : 'all',  // 'manual' / 'text' / 'all'\r\n        appendTarget       : null    // defaults to document.body once DOM has been loaded\r\n    },\r\n\r\n    hooks: {\r\n        beforeRemoveTag: () => Promise.resolve(),\r\n        beforePaste: () => Promise.resolve(),\r\n        suggestionClick: () => Promise.resolve(),\r\n        beforeKeyDown: () => Promise.resolve(),\r\n    }\r\n}", "import { sameStr, isObject, minify, getNodeHeight, getCaretGlobalPosition } from './helpers'\nimport suggestionsMethods from './suggestions'\n\nexport function initDropdown(){\n    this.dropdown = {}\n\n    // auto-bind \"this\" to all the dropdown methods\n    for( let p in this._dropdown )\n        this.dropdown[p] = typeof this._dropdown[p] === 'function'\n            ? this._dropdown[p].bind(this)\n            : this._dropdown[p]\n\n    this.dropdown.refs()\n    this.DOM.dropdown.__tagify = this\n}\n\nexport default {\n    ...suggestionsMethods,\n\n    refs(){\n        this.DOM.dropdown = this.parseTemplate('dropdown', [this.settings])\n        this.DOM.dropdown.content = this.DOM.dropdown.querySelector(\"[data-selector='tagify-suggestions-wrapper']\")\n    },\n\n    getHeaderRef(){\n        return this.DOM.dropdown.querySelector(\"[data-selector='tagify-suggestions-header']\")\n    },\n\n    getFooterRef(){\n        return this.DOM.dropdown.querySelector(\"[data-selector='tagify-suggestions-footer']\")\n    },\n\n    getAllSuggestionsRefs(){\n        return [...this.DOM.dropdown.content.querySelectorAll(this.settings.classNames.dropdownItemSelector)]\n    },\n\n    /**\n     * shows the suggestions select box\n     * @param {String} value [optional, filter the whitelist by this value]\n     */\n    show( value ){\n        var _s = this.settings,\n            firstListItem,\n            firstListItemValue,\n            allowNewTags = _s.mode == 'mix' && !_s.enforceWhitelist,\n            noWhitelist =  !_s.whitelist || !_s.whitelist.length,\n            noMatchListItem,\n            isManual = _s.dropdown.position == 'manual';\n\n        // if text still exists in the input, and `show` method has no argument, then the input's text should be used\n        value = value === undefined ? this.state.inputText : value\n\n        // ⚠️ Do not render suggestions list  if:\n        // 1. there's no whitelist (can happen while async loading) AND new tags arn't allowed\n        // 2. dropdown is disabled\n        // 3. loader is showing (controlled outside of this code)\n        if( (noWhitelist && !allowNewTags && !_s.templates.dropdownItemNoMatch)\n            || _s.dropdown.enabled === false\n            || this.state.isLoading\n            || this.settings.readonly )\n            return;\n\n        clearTimeout(this.dropdownHide__bindEventsTimeout)\n\n        // if no value was supplied, show all the \"whitelist\" items in the dropdown\n        // @type [Array] listItems\n        this.suggestedListItems = this.dropdown.filterListItems(value)\n\n        // trigger at this exact point to let the developer the chance to manually set \"this.suggestedListItems\"\n        if( value && !this.suggestedListItems.length ){\n            this.trigger('dropdown:noMatch', value)\n\n            if( _s.templates.dropdownItemNoMatch )\n                noMatchListItem = _s.templates.dropdownItemNoMatch.call(this, {value})\n        }\n\n        // if \"dropdownItemNoMatch\" was not defined, procceed regular flow.\n        //\n        if( !noMatchListItem ){\n            // in mix-mode, if the value isn't included in the whilelist & \"enforceWhitelist\" setting is \"false\",\n            // then add a custom suggestion item to the dropdown\n            if( this.suggestedListItems.length ){\n                if( value   &&   allowNewTags   &&   !this.state.editing.scope  &&  !sameStr(this.suggestedListItems[0].value, value) )\n                    this.suggestedListItems.unshift({value})\n            }\n            else{\n                if( value   &&   allowNewTags  &&  !this.state.editing.scope ){\n                    this.suggestedListItems = [{value}]\n                }\n                // hide suggestions list if no suggestion matched\n                else{\n                    this.input.autocomplete.suggest.call(this);\n                    this.dropdown.hide()\n                    return;\n                }\n            }\n\n            firstListItem =  this.suggestedListItems[0]\n            firstListItemValue = \"\"+(isObject(firstListItem) ? firstListItem.value : firstListItem)\n\n            if( _s.autoComplete && firstListItemValue ){\n                // only fill the sugegstion if the value of the first list item STARTS with the input value (regardless of \"fuzzysearch\" setting)\n                if( firstListItemValue.indexOf(value) == 0 )\n                    this.input.autocomplete.suggest.call(this, firstListItem)\n            }\n        }\n\n        this.dropdown.fill(noMatchListItem)\n\n        if( _s.dropdown.highlightFirst ) {\n            this.dropdown.highlightOption(this.DOM.dropdown.content.querySelector(_s.classNames.dropdownItemSelector))\n        }\n\n        // bind events, exactly at this stage of the code. \"dropdown.show\" method is allowed to be\n        // called multiple times, regardless if the dropdown is currently visible, but the events-binding\n        // should only be called if the dropdown wasn't previously visible.\n        if( !this.state.dropdown.visible )\n            // timeout is needed for when pressing arrow down to show the dropdown,\n            // so the key event won't get registered in the dropdown events listeners\n            setTimeout(this.dropdown.events.binding.bind(this))\n\n        // set the dropdown visible state to be the same as the searched value.\n        // MUST be set *before* position() is called\n        this.state.dropdown.visible = value || true\n        this.state.dropdown.query = value\n\n        this.setStateSelection()\n\n        // try to positioning the dropdown (it might not yet be on the page, doesn't matter, next code handles this)\n        if( !isManual ){\n            // a slight delay is needed if the dropdown \"position\" setting is \"text\", and nothing was typed in the input,\n            // so sadly the \"getCaretGlobalPosition\" method doesn't recognize the caret position without this delay\n            setTimeout(() => {\n                this.dropdown.position()\n                this.dropdown.render()\n            })\n        }\n\n        // a delay is needed because of the previous delay reason.\n        // this event must be fired after the dropdown was rendered & positioned\n        setTimeout(() => {\n            this.trigger(\"dropdown:show\", this.DOM.dropdown)\n        })\n    },\n\n    /**\n     * Hides the dropdown (if it's not managed manually by the developer)\n     * @param {Boolean} overrideManual\n     */\n    hide( overrideManual ){\n        var {scope, dropdown} = this.DOM,\n            isManual = this.settings.dropdown.position == 'manual' && !overrideManual;\n\n        // if there's no dropdown, this means the dropdown events aren't binded\n        if( !dropdown || !document.body.contains(dropdown) || isManual ) return;\n\n        window.removeEventListener('resize', this.dropdown.position)\n        this.dropdown.events.binding.call(this, false) // unbind all events\n\n        // if the dropdown is open, and the input (scope) is clicked,\n        // the dropdown should be now \"close\", and the next click (on the scope)\n        // should re-open it, and without a timeout, clicking to close will re-open immediately\n        //  clearTimeout(this.dropdownHide__bindEventsTimeout)\n        //  this.dropdownHide__bindEventsTimeout = setTimeout(this.events.binding.bind(this), 250)  // re-bind main events\n\n\n        scope.setAttribute(\"aria-expanded\", false)\n        dropdown.parentNode.removeChild(dropdown)\n\n        // scenario: clicking the scope to show the dropdown, clicking again to hide -> calls dropdown.hide() and then re-focuses the input\n        // which casues another onFocus event, which checked \"this.state.dropdown.visible\" and see it as \"false\" and re-open the dropdown\n        setTimeout(() => {\n            this.state.dropdown.visible = false\n        }, 100)\n\n        this.state.dropdown.query =\n        this.state.ddItemData =\n        this.state.ddItemElm =\n        this.state.selection = null\n\n        // if the user closed the dropdown (in mix-mode) while a potential tag was detected, flag the current tag\n        // so the dropdown won't be shown on following user input for that \"tag\"\n        if( this.state.tag && this.state.tag.value.length ){\n            this.state.flaggedTags[this.state.tag.baseOffset] = this.state.tag\n        }\n\n        this.trigger(\"dropdown:hide\", dropdown)\n\n        return this\n    },\n\n    /**\n     * Toggles dropdown show/hide\n     * @param {Boolean} show forces the dropdown to show\n     */\n    toggle(show){\n        this.dropdown[this.state.dropdown.visible && !show ? 'hide' : 'show']()\n    },\n\n    getAppendTarget() {\n        var _sd = this.settings.dropdown;\n        return typeof _sd.appendTarget === 'function' ? _sd.appendTarget() : _sd.appendTarget;\n    },\n\n    render(){\n        // let the element render in the DOM first, to accurately measure it.\n        // this.DOM.dropdown.style.cssText = \"left:-9999px; top:-9999px;\";\n        var ddHeight = getNodeHeight(this.DOM.dropdown),\n            _s = this.settings,\n            appendTarget = this.dropdown.getAppendTarget();\n\n        if( _s.dropdown.enabled === false ) return this;\n\n        this.DOM.scope.setAttribute(\"aria-expanded\", true)\n\n        // if the dropdown has yet to be appended to the DOM,\n        // append the dropdown to the body element & handle events\n        if( !document.body.contains(this.DOM.dropdown) ){\n            this.DOM.dropdown.classList.add( _s.classNames.dropdownInital )\n            this.dropdown.position(ddHeight)\n            appendTarget.appendChild(this.DOM.dropdown)\n\n            setTimeout(() =>\n                this.DOM.dropdown.classList.remove( _s.classNames.dropdownInital )\n            )\n        }\n\n        return this\n    },\n\n    /**\n     * re-renders the dropdown content element (see \"dropdownContent\" in templates file)\n     * @param {String/Array} HTMLContent - optional\n     */\n    fill( HTMLContent ){\n        HTMLContent = typeof HTMLContent == 'string'\n            ? HTMLContent\n            : this.dropdown.createListHTML(HTMLContent || this.suggestedListItems)\n\n        var dropdownContent = this.settings.templates.dropdownContent.call(this, HTMLContent)\n\n        this.DOM.dropdown.content.innerHTML = minify(dropdownContent)\n    },\n\n    /**\n     * Re-renders only the header & footer.\n     * Used when selecting a suggestion and it is wanted that the suggestions dropdown stays open.\n     * Since the list of sugegstions is not being re-rendered completely every time a suggestion is selected (the item is transitioned-out)\n     * then the header & footer should be kept in sync with the suggestions data change\n     */\n    fillHeaderFooter(){\n        var suggestions = this.dropdown.filterListItems(this.state.dropdown.query),\n            newHeaderElem = this.parseTemplate('dropdownHeader', [suggestions]),\n            newFooterElem = this.parseTemplate('dropdownFooter', [suggestions]),\n            headerRef = this.dropdown.getHeaderRef(),\n            footerRef = this.dropdown.getFooterRef();\n\n        newHeaderElem && headerRef?.parentNode.replaceChild(newHeaderElem, headerRef)\n        newFooterElem && footerRef?.parentNode.replaceChild(newFooterElem, footerRef)\n    },\n\n    /**\n     * dropdown positioning logic\n     * (shown above/below or next to typed text for mix-mode)\n     */\n    position( ddHeight ){\n        var _sd = this.settings.dropdown,\n            appendTarget = this.dropdown.getAppendTarget();\n\n        if( _sd.position == 'manual' || !appendTarget) return\n\n        var rect, top, bottom, left, width, ancestorsOffsets,\n            isPlacedAbove,\n            cssTop, cssLeft,\n            ddElm = this.DOM.dropdown,\n            isRTL = _sd.RTL,\n            isDefaultAppendTarget = appendTarget === document.body,\n            isSelfAppended = appendTarget === this.DOM.scope,\n            appendTargetScrollTop = isDefaultAppendTarget ? window.pageYOffset : appendTarget.scrollTop,\n            root = document.fullscreenElement || document.webkitFullscreenElement || document.documentElement,\n            viewportHeight = root.clientHeight,\n            viewportWidth = Math.max(root.clientWidth || 0, window.innerWidth || 0),\n            positionTo = viewportWidth > 480 ? _sd.position : 'all',\n            ddTarget = this.DOM[positionTo == 'input' ? 'input' : 'scope'];\n\n        ddHeight = ddHeight || ddElm.clientHeight\n\n        function getAncestorsOffsets(p){\n            var top = 0, left = 0;\n\n            p = p.parentNode;\n\n            // when in element-fullscreen mode, do not go above the fullscreened-element\n            while(p && p != root){\n                top += p.offsetTop || 0\n                left += p.offsetLeft || 0\n                p = p.parentNode\n            }\n\n            return {top, left};\n        }\n\n        function getAccumulatedAncestorsScrollTop() {\n            var scrollTop = 0,\n                p = _sd.appendTarget.parentNode;\n\n            while(p){\n                scrollTop += p.scrollTop || 0;\n                p = p.parentNode\n            }\n\n            return scrollTop;\n        }\n\n        if( !this.state.dropdown.visible ) return\n\n        if( positionTo == 'text' ){\n            rect   = getCaretGlobalPosition()\n            bottom = rect.bottom\n            top    = rect.top\n            left   = rect.left\n            width  = 'auto'\n        }\n\n        else{\n            ancestorsOffsets = getAncestorsOffsets(appendTarget)\n            rect   = ddTarget.getBoundingClientRect()\n            top    = isSelfAppended ? -1 : rect.top - ancestorsOffsets.top\n            bottom = (isSelfAppended ? rect.height : rect.bottom - ancestorsOffsets.top) - 1\n            left   = isSelfAppended ? -1 : rect.left - ancestorsOffsets.left\n            width  = rect.width + 'px'\n        }\n\n        // if the \"append target\" isn't the default, correct the `top` variable by ignoring any scrollTop of the target's Ancestors\n        if( !isDefaultAppendTarget ) {\n            let accumulatedAncestorsScrollTop = getAccumulatedAncestorsScrollTop()\n            top += accumulatedAncestorsScrollTop\n            bottom += accumulatedAncestorsScrollTop\n        }\n\n        top = Math.floor(top)\n        bottom = Math.ceil(bottom)\n\n        isPlacedAbove = _sd.placeAbove ?? viewportHeight - rect.bottom < ddHeight\n\n        // flip vertically if there is no space for the dropdown below the input\n        cssTop = (isPlacedAbove ? top : bottom) + appendTargetScrollTop;\n\n        // \"pageXOffset\" property is an alias for \"scrollX\"\n        cssLeft = `left: ${(left + (isRTL ? (rect.width || 0) : 0) + window.pageXOffset)}px;`\n\n       // rtl = rtl ?? viewportWidth -\n        ddElm.style.cssText = `${cssLeft}; top: ${cssTop}px; min-width: ${width}; max-width: ${width}`;\n\n        ddElm.setAttribute('placement', isPlacedAbove ? 'top' : 'bottom')\n        ddElm.setAttribute('position', positionTo)\n    },\n}\n", "import { isObject, escapeHTML, extend, unaccent, logger } from './helpers'\n\n\n/**\n * Tagify's dropdown suggestions-related logic\n */\n\nexport default {\n    events : {\n        /**\n         * Events should only be binded when the dropdown is rendered and removed when isn't\n         * because there might be multiple Tagify instances on a certain page\n         * @param  {Boolean} bindUnbind [optional. true when wanting to unbind all the events]\n         */\n        binding( bindUnbind = true ){\n            // references to the \".bind()\" methods must be saved so they could be unbinded later\n            var _CB = this.dropdown.events.callbacks,\n                // callback-refs\n                _CBR = (this.listeners.dropdown = this.listeners.dropdown || {\n                    position          : this.dropdown.position.bind(this, null),\n                    onKeyDown         : _CB.onKeyDown.bind(this),\n                    onMouseOver       : _CB.onMouseOver.bind(this),\n                    onMouseLeave      : _CB.onMouseLeave.bind(this),\n                    onClick           : _CB.onClick.bind(this),\n                    onScroll          : _CB.onScroll.bind(this),\n                }),\n                action = bindUnbind ? 'addEventListener' : 'removeEventListener';\n\n            if( this.settings.dropdown.position != 'manual' ){\n                document[action]('scroll', _CBR.position, true)\n                window[action]('resize', _CBR.position)\n                window[action]('keydown', _CBR.onKeyDown)\n            }\n\n            this.DOM.dropdown[action]('mouseover', _CBR.onMouseOver)\n            this.DOM.dropdown[action]('mouseleave', _CBR.onMouseLeave)\n            this.DOM.dropdown[action]('mousedown', _CBR.onClick)\n            this.DOM.dropdown.content[action]('scroll', _CBR.onScroll)\n        },\n\n        callbacks : {\n            onKeyDown(e){\n                // ignore keys during IME composition\n                if( !this.state.hasFocus || this.state.composing )\n                    return\n\n                // get the \"active\" element, and if there was none (yet) active, use first child\n                var _s = this.settings,\n                    selectedElm = this.DOM.dropdown.querySelector(_s.classNames.dropdownItemActiveSelector),\n                    selectedElmData = this.dropdown.getSuggestionDataByNode(selectedElm),\n                    isMixMode = _s.mode == 'mix',\n                    isSelectMode = _s.mode == 'select';\n\n                _s.hooks.beforeKeyDown(e, {tagify:this})\n                    .then(result => {\n                        switch( e.key ){\n                            case 'ArrowDown' :\n                            case 'ArrowUp' :\n                            case 'Down' :  // >IE11\n                            case 'Up' : {  // >IE11\n                                e.preventDefault()\n                                var dropdownItems = this.dropdown.getAllSuggestionsRefs(),\n                                    actionUp = e.key == 'ArrowUp' || e.key == 'Up';\n\n                                if( selectedElm ) {\n                                    selectedElm = this.dropdown.getNextOrPrevOption(selectedElm, !actionUp)\n                                }\n\n                                // if no element was found OR current item is not a \"real\" item, loop\n                                if( !selectedElm || !selectedElm.matches(_s.classNames.dropdownItemSelector) ){\n                                    selectedElm = dropdownItems[actionUp ? dropdownItems.length - 1 : 0];\n                                }\n\n                                this.dropdown.highlightOption(selectedElm, true)\n                                // selectedElm.scrollIntoView({inline: 'nearest', behavior: 'smooth'})\n                                break;\n                            }\n                            case 'PageUp':\n                            case 'PageDown': {\n                                e.preventDefault()\n                                const dropdownItems = this.dropdown.getAllSuggestionsRefs()\n                                const itemsPerPage = Math.floor(this.DOM.dropdown.content.clientHeight / dropdownItems[0]?.offsetHeight) || 1\n                                const isPageUp = e.key === 'PageUp'\n\n                                if (selectedElm) {\n                                    const currentIndex = dropdownItems.indexOf(selectedElm)\n                                    const targetIndex = isPageUp\n                                        ? Math.max(0, currentIndex - itemsPerPage)\n                                        : Math.min(dropdownItems.length - 1, currentIndex + itemsPerPage)\n                                    selectedElm = dropdownItems[targetIndex]\n                                } else {\n                                    selectedElm = dropdownItems[0]\n                                }\n\n                                this.dropdown.highlightOption(selectedElm, true)\n                                break;\n                            }\n                            case 'Home':\n                            case 'End': {\n                                e.preventDefault()\n                                const dropdownItems = this.dropdown.getAllSuggestionsRefs()\n                                selectedElm = dropdownItems[e.key === 'Home' ? 0 : dropdownItems.length - 1]\n                                this.dropdown.highlightOption(selectedElm, true)\n                                break;\n                            }\n                            case 'Escape' :\n                            case 'Esc': // IE11\n                                this.dropdown.hide();\n                                break;\n\n                            case 'ArrowRight' :\n                                // do not continue if the left arrow key was pressed while typing, because assuming the user wants to bypass any of the below logic and edit the content without intervention.\n                                // also do not procceed if a tag should be created when the setting `autoComplete.rightKey` is set to `true`\n                                if( this.state.actions.ArrowLeft || _s.autoComplete.rightKey )\n                                    return\n                            case 'Tab' : {\n                                let shouldAutocompleteOnKey = !_s.autoComplete.rightKey || !_s.autoComplete.tabKey\n\n                                // in mix-mode, treat arrowRight like Enter key, so a tag will be created\n                                if( !isMixMode && !isSelectMode && selectedElm && shouldAutocompleteOnKey && !this.state.editing && selectedElmData ){\n                                    e.preventDefault() // prevents blur so the autocomplete suggestion will not become a tag\n                                    var value = this.dropdown.getMappedValue(selectedElmData)\n\n                                    this.state.autoCompleteData = selectedElmData;\n                                    this.input.autocomplete.set.call(this, value)\n                                    return false\n                                }\n                                return true\n                            }\n                            case 'Enter' : {\n                                e.preventDefault()\n\n                                // temporary set the \"actions\" state to indicate to the main \"blur\" event it shouldn't execute any if its logic.\n                                // a `100ms` is a good-enough timeout after some testing\n                                this.state.actions.selectOption = true;\n                                setTimeout(()=> this.state.actions.selectOption = false, 100)\n\n                                _s.hooks.suggestionClick(e, {tagify:this, tagData:selectedElmData, suggestionElm:selectedElm})\n                                    .then(() => {\n                                        if( selectedElm ){\n                                            this.dropdown.selectOption(selectedElm)\n                                            // highlight next option\n                                            selectedElm = this.dropdown.getNextOrPrevOption(selectedElm, !actionUp)\n                                            this.dropdown.highlightOption(selectedElm)\n                                            return\n                                        }\n                                        else\n                                            this.dropdown.hide()\n\n                                        if( !isMixMode )\n                                            this.addTags(this.state.inputText.trim(), true)\n                                    })\n                                    .catch(err => logger.warn(err))\n\n                                break;\n                            }\n                            case 'Backspace' : {\n                                if( isMixMode || this.state.editing.scope ) return;\n\n                                const value = this.input.raw.call(this)\n\n                                if( value == \"\" || value.charCodeAt(0) == 8203 ){\n                                    if( _s.backspace === true )\n                                        this.removeTags()\n                                    else if( _s.backspace == 'edit' )\n                                        setTimeout(this.editTag.bind(this), 0)\n                                }\n                            }\n                        }\n                    })\n            },\n\n            onMouseOver(e){\n                var ddItem = e.target.closest(this.settings.classNames.dropdownItemSelector)\n                // event delegation check\n                this.dropdown.highlightOption(ddItem)\n            },\n\n            onMouseLeave(e){\n                // de-highlight any previously highlighted option\n                this.dropdown.highlightOption()\n            },\n\n            onClick(e){\n                if( e.button != 0 || e.target == this.DOM.dropdown || e.target == this.DOM.dropdown.content ) return; // allow only mouse left-clicks\n\n                var selectedElm = e.target.closest(this.settings.classNames.dropdownItemSelector),\n                    selectedElmData = this.dropdown.getSuggestionDataByNode(selectedElm)\n\n                // temporary set the \"actions\" state to indicate to the main \"blur\" event it shouldn't execute any if its logic.\n                // a `100ms` is a good-enough timeout after some testing\n                this.state.actions.selectOption = true;\n                setTimeout(()=> this.state.actions.selectOption = false, 100)\n\n                this.settings.hooks.suggestionClick(e, {tagify:this, tagData:selectedElmData, suggestionElm:selectedElm})\n                    .then(() => {\n                        if( selectedElm )\n                            this.dropdown.selectOption(selectedElm, e)\n                        else\n                            this.dropdown.hide()\n                    })\n                    .catch(err => logger.warn(err))\n            },\n\n            onScroll(e){\n                var elm = e.target,\n                    pos = elm.scrollTop / (elm.scrollHeight - elm.parentNode.clientHeight) * 100;\n\n                this.trigger(\"dropdown:scroll\", {percentage:Math.round(pos)})\n            },\n        }\n    },\n\n    /**\n     * fill data into the suggestions list\n     * (mainly used to update the list when removing tags while the suggestions dropdown is visible, so they will be re-added to the list. not efficient)\n     */\n    refilter( value ){\n        value = value || this.state.dropdown.query || ''\n        this.suggestedListItems = this.dropdown.filterListItems(value)\n\n        this.dropdown.fill()\n\n        if( !this.suggestedListItems.length )\n            this.dropdown.hide()\n\n        this.trigger(\"dropdown:updated\", this.DOM.dropdown)\n    },\n\n    /**\n     * Given a suggestion-item, return the data associated with it\n     * @param {HTMLElement} tagElm\n     * @returns Object\n     */\n    getSuggestionDataByNode( tagElm ){\n        var item, value = tagElm && tagElm.getAttribute('value')\n\n        for(var i = this.suggestedListItems.length; i--; ) {\n            item = this.suggestedListItems[i]\n            if( isObject(item) && item.value == value ) return item\n            // for primitive whitelist items:\n            else if( item == value ) return {value: item}\n        }\n    },\n\n    getNextOrPrevOption(selected, next = true) {\n        var dropdownItems = this.dropdown.getAllSuggestionsRefs(),\n            selectedIdx = dropdownItems.findIndex(item => item === selected);\n\n        return next ? dropdownItems[selectedIdx + 1] : dropdownItems[selectedIdx - 1]\n    },\n\n    /**\n     * mark the currently active suggestion option\n     * @param {Object}  elm            option DOM node\n     * @param {Boolean} adjustScroll   when navigation with keyboard arrows (up/down), aut-scroll to always show the highlighted element\n     */\n    highlightOption( elm, adjustScroll ){\n        var className = this.settings.classNames.dropdownItemActive,\n            itemData;\n\n        // focus casues a bug in Firefox with the placeholder been shown on the input element\n        // if( this.settings.dropdown.position != 'manual' )\n        //     elm.focus();\n\n        if( this.state.ddItemElm ){\n            this.state.ddItemElm.classList.remove(className)\n            this.state.ddItemElm.removeAttribute(\"aria-selected\")\n        }\n\n        if( !elm ){\n            this.state.ddItemData = null\n            this.state.ddItemElm = null\n            this.input.autocomplete.suggest.call(this)\n            return;\n        }\n\n        itemData = this.dropdown.getSuggestionDataByNode(elm)\n        this.state.ddItemData = itemData\n        this.state.ddItemElm = elm\n\n        // this.DOM.dropdown.querySelectorAll(\".\" + this.settings.classNames.dropdownItemActive).forEach(activeElm => activeElm.classList.remove(className));\n        elm.classList.add(className);\n        elm.setAttribute(\"aria-selected\", true)\n\n        if( adjustScroll )\n            elm.parentNode.scrollTop = elm.clientHeight + elm.offsetTop - elm.parentNode.clientHeight\n\n        // Try to autocomplete the typed value with the currently highlighted dropdown item\n        if( this.settings.autoComplete ){\n            this.input.autocomplete.suggest.call(this, itemData)\n            this.dropdown.position() // suggestions might alter the height of the tagify wrapper because of unkown suggested term length that could drop to the next line\n        }\n    },\n\n    /**\n     * Create a tag from the currently active suggestion option\n     * @param {Object} elm  DOM node to select\n     * @param {Object} event The original Click event, if available (since keyboard ENTER key also triggers this method)\n     */\n    selectOption( elm, event ){\n        var _s = this.settings,\n            {clearOnSelect, closeOnSelect} = _s.dropdown;\n\n        if( !elm ) {\n            this.addTags(this.state.inputText, true)\n            closeOnSelect && this.dropdown.hide()\n            return;\n        }\n\n        event = event || {}\n\n        // if in edit-mode, do not continue but instead replace the tag's text.\n        // the scenario is that \"addTags\" was called from a dropdown suggested option selected while editing\n\n        var value = elm.getAttribute('value'),\n            isNoMatch = value == 'noMatch',\n            isMixMode = _s.mode == 'mix',\n            tagData = this.suggestedListItems.find(item => (item.value ?? item) == value)\n\n        // The below event must be triggered, regardless of anything else which might go wrong\n        this.trigger('dropdown:select', {data:tagData, elm, event})\n\n        if( !tagData && !isNoMatch ){\n            closeOnSelect && setTimeout(this.dropdown.hide.bind(this))\n            return\n        }\n\n        if( this.state.editing ) {\n            let normalizedTagData = this.normalizeTags([tagData])[0]\n            tagData = _s.transformTag.call(this, normalizedTagData) || normalizedTagData\n\n            // normalizing value, because \"tagData\" might be a string, and therefore will not be able to extend the object\n            this.onEditTagDone(null, extend({__isValid: true}, tagData))\n        }\n        // Tagify instances should re-focus to the input element once an option was selected, to allow continuous typing\n        else {\n            this[isMixMode ? \"addMixTags\" : \"addTags\"]([tagData || this.input.raw.call(this)], clearOnSelect)\n        }\n\n        if( !isMixMode && !this.DOM.input.parentNode )\n            return\n\n        setTimeout(() => {\n            this.DOM.input.focus()\n            this.toggleFocusClass(true)\n        })\n\n        closeOnSelect && setTimeout(this.dropdown.hide.bind(this))\n\n        // execute these tasks once a suggestion has been selected\n        elm.addEventListener('transitionend', () => {\n            this.dropdown.fillHeaderFooter()\n            setTimeout(() => {\n                elm.remove()\n                this.dropdown.refilter()\n            }, 100)\n        }, {once: true})\n\n        // hide selected suggestion\n        elm.classList.add(this.settings.classNames.dropdownItemHidden)\n    },\n\n    // adds all the suggested items, including the ones which are not currently rendered,\n    // unless specified otherwise (by the \"onlyRendered\" argument)\n    selectAll( onlyRendered ){\n        // having suggestedListItems with items messes with \"normalizeTags\" when wanting\n        // to add all tags\n        this.suggestedListItems.length = 0;\n        this.dropdown.hide()\n\n        this.dropdown.filterListItems('');\n\n        var tagsToAdd = this.dropdown.filterListItems('');\n\n        if( !onlyRendered )\n            tagsToAdd = this.state.dropdown.suggestions\n\n        // some whitelist items might have already been added as tags so when addings all of them,\n        // skip adding already-added ones, so best to use \"filterListItems\" method over \"settings.whitelist\"\n        this.addTags(tagsToAdd, true)\n        return this\n    },\n\n    /**\n     * returns an HTML string of the suggestions' list items\n     * @param {String} value string to filter the whitelist by\n     * @param {Object} options \"exact\" - for exact complete match\n     * @return {Array} list of filtered whitelist items according to the settings provided and current value\n     */\n    filterListItems( value, options ){\n        var _s = this.settings,\n            _sd = _s.dropdown,\n            options = options || {},\n            list = [],\n            exactMatchesList = [],\n            whitelist = _s.whitelist,\n            suggestionsCount = _sd.maxItems >= 0 ? _sd.maxItems : Infinity,\n            includeSelectedTags = _sd.includeSelectedTags || _s.mode == 'select',\n            hasCustomSort = typeof _sd.sortby == 'function',\n            searchKeys = _sd.searchKeys,\n            whitelistItem,\n            valueIsInWhitelist,\n            searchBy,\n            isDuplicate,\n            niddle,\n            i = 0;\n\n        value = (_s.mode == 'select' && this.value.length && this.value[0][_s.tagTextProp] == value\n            ? '' // do not filter if the tag, which is already selecetd in \"select\" mode, is the same as the typed text\n            : value);\n\n        if( !value || !searchKeys.length ){\n            list = includeSelectedTags\n                ? whitelist\n                : whitelist.filter(item => !this.isTagDuplicate( isObject(item) ? item.value : item )) // don't include tags which have already been added.\n\n            var filteredList = hasCustomSort\n                ? _sd.sortby(list, niddle)\n                : list.slice(0, suggestionsCount); // respect \"maxItems\" dropdown setting\n\n            this.state.dropdown.suggestions = filteredList;\n\n            return filteredList;\n        }\n\n        niddle = _sd.caseSensitive\n            ? \"\"+value\n            : (\"\"+value).toLowerCase()\n\n        // checks if ALL of the words in the search query exists in the current whitelist item, regardless of their order\n        function stringHasAll(s, query){\n            return query.toLowerCase().split(' ').every(q => s.includes(q.toLowerCase()))\n        }\n\n        for( ; i < whitelist.length; i++ ){\n            let startsWithMatch, exactMatch;\n\n            whitelistItem = whitelist[i] instanceof Object ? whitelist[i] : { value:whitelist[i] } //normalize value as an Object\n\n            let itemWithoutSearchKeys = !Object.keys(whitelistItem).some(k => searchKeys.includes(k) ),\n                _searchKeys = itemWithoutSearchKeys ? [\"value\"] : searchKeys\n\n            if( _sd.fuzzySearch && !options.exact ){\n                searchBy = _searchKeys.reduce((values, k) => values + \" \" + (whitelistItem[k]||\"\"), \"\").toLowerCase().trim()\n\n                if( _sd.accentedSearch ){\n                    searchBy = unaccent(searchBy)\n                    niddle = unaccent(niddle)\n                }\n\n                startsWithMatch = searchBy.indexOf(niddle) == 0\n                exactMatch = searchBy === niddle\n                valueIsInWhitelist = stringHasAll(searchBy, niddle)\n            }\n\n            else {\n                startsWithMatch = true;\n                valueIsInWhitelist = _searchKeys.some(k => {\n                    var v = '' + (whitelistItem[k] || '') // if key exists, cast to type String\n\n                    if( _sd.accentedSearch ){\n                        v = unaccent(v)\n                        niddle = unaccent(niddle)\n                    }\n\n                    if( !_sd.caseSensitive )\n                        v = v.toLowerCase()\n\n                    exactMatch = v === niddle\n\n                    return options.exact\n                        ? v === niddle\n                        : v.indexOf(niddle) == 0\n                })\n            }\n\n            isDuplicate = !_sd.includeSelectedTags && this.isTagDuplicate( isObject(whitelistItem) ? whitelistItem.value : whitelistItem )\n\n            // match for the value within each \"whitelist\" item\n            if( valueIsInWhitelist && !isDuplicate )\n                if( exactMatch && startsWithMatch)\n                    exactMatchesList.push(whitelistItem)\n                else if( _sd.sortby == 'startsWith' && startsWithMatch )\n                    list.unshift(whitelistItem)\n                else\n                    list.push(whitelistItem)\n        }\n\n        this.state.dropdown.suggestions = exactMatchesList.concat(list);\n\n        // custom sorting function\n        var filteredList = hasCustomSort\n            ? _sd.sortby(exactMatchesList.concat(list), niddle)\n            : exactMatchesList.concat(list).slice(0, suggestionsCount)\n\n        this.state.dropdown.suggestions = filteredList;\n        return filteredList\n    },\n\n    /**\n     * Returns the final value of a tag data (object) with regards to the \"mapValueTo\" dropdown setting\n     * @param {Object} tagData\n     * @returns\n     */\n    getMappedValue(tagData){\n        var mapValueTo = this.settings.dropdown.mapValueTo,\n            value = (mapValueTo\n                ? typeof mapValueTo == 'function' ? mapValueTo(tagData) : (tagData[mapValueTo] || tagData.value)\n                : tagData.value);\n\n        return value\n    },\n\n    /**\n     * Creates the dropdown items' HTML\n     * @param  {Array} sugegstionsList  [Array of Objects]\n     * @return {String}\n     */\n    createListHTML( sugegstionsList ){\n        return extend([], sugegstionsList).map((suggestion, idx) => {\n            if( typeof suggestion == 'string' || typeof suggestion == 'number' )\n                suggestion = {value:suggestion}\n\n            var mappedValue = this.dropdown.getMappedValue(suggestion);\n\n            mappedValue = (typeof mappedValue == 'string' && this.settings.dropdown.escapeHTML)\n                ? escapeHTML(mappedValue)\n                : mappedValue;\n\n            return this.settings.templates.dropdownItem.apply(this, [{...suggestion, mappedValue}, this])\n        }).join(\"\")\n    }\n}", "const VERSION = 1; // current version of persisted data. if code change breaks persisted data, verison number should be bumped.\nconst STORE_KEY = '@yaireo/tagify/'\n\nexport const getPersistedData = id => key => {\n    if( !id ) return;\n\n    // if \"persist\" is \"false\", do not save to localstorage\n    let customKey = '/'+key,\n        persistedData,\n        currentStorageVersion = localStorage?.getItem(STORE_KEY + id + '/v')\n\n    if( currentStorageVersion === VERSION){\n        try{ persistedData = JSON.parse(localStorage[STORE_KEY + id + customKey]) }\n        catch(err){}\n    }\n\n    return persistedData\n}\n\nexport const setPersistedData = id => {\n    if( !id ) return () => {};\n\n    // for storage invalidation\n    localStorage?.setItem(STORE_KEY + id + '/v', VERSION)\n\n    return (data, key) => {\n        let customKey = '/'+key,\n            persistedData = JSON.stringify(data)\n\n        if( data && key ){\n            localStorage?.setItem(STORE_KEY + id + customKey, persistedData)\n            dispatchEvent( new Event('storage') )\n        }\n    }\n}\n\nexport const clearPersistedData = id => key => {\n    const base = STORE_KEY + '/' + id + '/';\n\n    // delete specific key in the storage\n    if( key )\n        localStorage.removeItem(base + key)\n\n    // delete all keys in the storage with a specific tagify id\n    else {\n        for(let k in localStorage)\n            if( k.includes(base) )\n                localStorage.removeItem(k)\n    }\n}\n", "export default {\r\n    empty      : \"empty\",\r\n    exceed     : \"number of tags exceeded\",\r\n    pattern    : \"pattern mismatch\",\r\n    duplicate  : \"already exists\",\r\n    notAllowed : \"not allowed\"\r\n}", "import {ZERO_WIDTH_UNICODE_CHAR} from './constants'\r\n\r\nexport default {\r\n    /**\r\n     *\r\n     * @param {DOM Object} input     Original input DOm element\r\n     * @param {Object}     settings  Tagify instance settings Object\r\n     */\r\n    wrapper(input, _s){\r\n        return `<tags class=\"${_s.classNames.namespace} ${_s.mode ? `${_s.classNames[_s.mode + \"Mode\"]}` : \"\"} ${input.className}\"\r\n                    ${_s.readonly ? 'readonly' : ''}\r\n                    ${_s.disabled ? 'disabled' : ''}\r\n                    ${_s.required ? 'required' : ''}\r\n                    ${_s.mode === 'select' ? \"spellcheck='false'\" : ''}\r\n                    tabIndex=\"-1\">\r\n                    ${this.settings.templates.input.call(this)}\r\n                ${ZERO_WIDTH_UNICODE_CHAR}\r\n        </tags>`\r\n    },\r\n\r\n    input() {\r\n        var _s = this.settings,\r\n            placeholder = _s.placeholder || ZERO_WIDTH_UNICODE_CHAR;\r\n\r\n        return `<span ${!_s.readonly && _s.userInput ? 'contenteditable' : ''} tabIndex=\"0\" data-placeholder=\"${placeholder}\" aria-placeholder=\"${_s.placeholder || ''}\"\r\n                    class=\"${_s.classNames.input}\"\r\n                    role=\"textbox\"\r\n                    autocapitalize=\"false\"\r\n                    autocorrect=\"off\"\r\n                    aria-autocomplete=\"both\"\r\n                    aria-multiline=\"${_s.mode=='mix'?true:false}\"></span>`\r\n    },\r\n\r\n    tag(tagData, {settings: _s}){\r\n        return `<tag title=\"${(tagData.title || tagData.value)}\"\r\n                    contenteditable='false'\r\n                    tabIndex=\"${_s.a11y.focusableTags ? 0 : -1}\"\r\n                    class=\"${_s.classNames.tag} ${tagData.class || \"\"}\"\r\n                    ${this.getAttributes(tagData)}>\r\n            <x title='' tabIndex=\"${_s.a11y.focusableTags ? 0 : -1}\" class=\"${_s.classNames.tagX}\" role='button' aria-label='remove tag'></x>\r\n            <div>\r\n                <span ${_s.mode === 'select' && _s.userInput ? \"contenteditable='true'\" : ''} autocapitalize=\"false\" autocorrect=\"off\" spellcheck='false' class=\"${_s.classNames.tagText}\">${tagData[_s.tagTextProp] || tagData.value}</span>\r\n            </div>\r\n        </tag>`\r\n    },\r\n\r\n    dropdown(settings){\r\n        var _sd = settings.dropdown,\r\n            isManual = _sd.position == 'manual';\r\n\r\n        return `<div class=\"${isManual ? '' : settings.classNames.dropdown } ${_sd.classname}\" role=\"listbox\" aria-labelledby=\"dropdown\" dir=\"${_sd.RTL ? 'rtl' : ''}\">\r\n                    <div data-selector='tagify-suggestions-wrapper' class=\"${settings.classNames.dropdownWrapper}\"></div>\r\n                </div>`\r\n    },\r\n\r\n    dropdownContent(HTMLContent) {\r\n        var _t = this.settings.templates,\r\n            suggestions = this.state.dropdown.suggestions;\r\n\r\n        return `\r\n            ${_t.dropdownHeader.call(this, suggestions)}\r\n            ${HTMLContent}\r\n            ${_t.dropdownFooter.call(this, suggestions)}\r\n        `\r\n    },\r\n\r\n    dropdownItem(item){\r\n        return `<div ${this.getAttributes(item)}\r\n                    class='${this.settings.classNames.dropdownItem} ${this.isTagDuplicate(item.value) ? this.settings.classNames.dropdownItemSelected: \"\"} ${item.class || \"\"}'\r\n                    tabindex=\"0\"\r\n                    role=\"option\">${item.mappedValue || item.value}</div>`\r\n    },\r\n\r\n    /**\r\n     * @param {Array} suggestions An array of all the matched suggested items, including those which were sliced away due to the \"dropdown.maxItems\" setting\r\n     */\r\n    dropdownHeader(suggestions){\r\n        return `<header data-selector='tagify-suggestions-header' class=\"${this.settings.classNames.dropdownHeader}\"></header>`\r\n    },\r\n\r\n    dropdownFooter(suggestions){\r\n        var hasMore = suggestions.length - this.settings.dropdown.maxItems;\r\n\r\n        return hasMore > 0\r\n            ? `<footer data-selector='tagify-suggestions-footer' class=\"${this.settings.classNames.dropdownFooter}\">\r\n                ${hasMore} more items. Refine your search.\r\n            </footer>`\r\n            : '';\r\n    },\r\n\r\n    dropdownItemNoMatch: null\r\n}\r\n", "import { decode, extend, getfirstTextNode, isChromeAndroidBrowser, isNodeTag, isWithinNodeTag, injectAtCaret, getSetTagData, fixCaretBetweenTags, placeCaretAfterNode } from './helpers'\nimport {ZERO_WIDTH_CHAR} from './constants'\n\nexport function triggerChangeEvent(){\n    if( this.settings.mixMode.integrated ) return;\n\n    var inputElm = this.DOM.originalInput,\n        changed = this.state.lastOriginalValueReported !== inputElm.value,\n        event = new CustomEvent(\"change\", {bubbles: true}); // must use \"CustomEvent\" and not \"Event\" to support IE\n\n    if( !changed ) return;\n\n    // must apply this BEFORE triggering the simulated event\n    this.state.lastOriginalValueReported = inputElm.value\n\n    // React hack: https://github.com/facebook/react/issues/11488\n    event.simulated = true\n    if (inputElm._valueTracker)\n        inputElm._valueTracker.setValue(Math.random())\n\n    inputElm.dispatchEvent(event)\n\n    // also trigger a Tagify event\n    this.trigger(\"change\", this.state.lastOriginalValueReported)\n\n    // React, for some reason, clears the input's value after \"dispatchEvent\" is fired\n    inputElm.value = this.state.lastOriginalValueReported\n}\n\nexport default {\n    // bind custom events which were passed in the settings\n    customBinding(){\n        this.customEventsList.forEach(name => {\n            this.on(name, this.settings.callbacks[name])\n        })\n    },\n\n    binding( bindUnbind = true ){\n        var _s = this.settings,\n            _CB = this.events.callbacks,\n            _CBR,\n            action = bindUnbind ? 'addEventListener' : 'removeEventListener';\n\n        // do not allow the main events to be bound more than once\n        if( this.state.mainEvents && bindUnbind )\n            return;\n\n        // set the binding state of the main events, so they will not be bound more than once\n        this.state.mainEvents = bindUnbind;\n\n        // everything inside gets executed only once-per instance\n        if( bindUnbind && !this.listeners.main ){\n            this.events.bindGlobal.call(this);\n\n            if( this.settings.isJQueryPlugin )\n                jQuery(this.DOM.originalInput).on('tagify.removeAllTags', this.removeAllTags.bind(this))\n        }\n\n        // setup callback references so events could be removed later\n        _CBR = (this.listeners.main = this.listeners.main || {\n            keydown          : ['input', _CB.onKeydown.bind(this)],\n            click            : ['scope', _CB.onClickScope.bind(this)],\n            dblclick         : _s.mode != 'select' && ['scope', _CB.onDoubleClickScope.bind(this)],\n            paste            : ['input', _CB.onPaste.bind(this)],\n            drop             : ['input', _CB.onDrop.bind(this)],\n            compositionstart : ['input', _CB.onCompositionStart.bind(this)],\n            compositionend   : ['input', _CB.onCompositionEnd.bind(this)]\n        })\n\n        for( var eventName in _CBR ){\n            _CBR[eventName] && this.DOM[_CBR[eventName][0]][action](eventName, _CBR[eventName][1]);\n        }\n\n        // observers\n        var inputMutationObserver = this.listeners.main.inputMutationObserver || new MutationObserver(_CB.onInputDOMChange.bind(this));\n\n        // cleaup just-in-case\n        inputMutationObserver.disconnect()\n\n        // observe stuff\n        if( _s.mode == 'mix' ) {\n            inputMutationObserver.observe(this.DOM.input, {childList:true})\n        }\n\n        this.events.bindOriginaInputListener.call(this)\n    },\n\n    bindOriginaInputListener(delay) {\n        const DELAY = (delay||0) + 500\n\n        if(!this.listeners.main) return\n        // listen to original input changes (unfortunetly this is the best way...)\n        // https://stackoverflow.com/a/1949416/104380\n        clearInterval(this.listeners.main.originalInputValueObserverInterval)\n        this.listeners.main.originalInputValueObserverInterval = setInterval(this.events.callbacks.observeOriginalInputValue.bind(this), DELAY)\n    },\n\n    bindGlobal( unbind ) {\n        var _CB = this.events.callbacks,\n            action = unbind ? 'removeEventListener' : 'addEventListener',\n            e;\n\n        if( !this.listeners || (!unbind  && this.listeners.global) ) return; // do not re-bind\n\n        // these events are global and should never be unbinded, unless the instance is destroyed:\n        this.listeners.global = this.listeners.global || [\n            {\n                type: this.isIE ? 'keydown' : 'input',  // IE cannot register \"input\" events on contenteditable elements, so the \"keydown\" should be used instead..\n                target: this.DOM.input,\n                cb: _CB[this.isIE ? 'onInputIE' : 'onInput'].bind(this)\n            },\n            {\n                type: 'keydown',\n                target: window,\n                cb: _CB.onWindowKeyDown.bind(this)\n            },\n            {\n                type: 'focusin',\n                target: this.DOM.scope,\n                cb: _CB.onFocusBlur.bind(this)\n            },\n            {\n                type: 'focusout',\n                target: this.DOM.scope,\n                cb: _CB.onFocusBlur.bind(this)\n            },\n            {\n                type: 'click',\n                target: document,\n                cb: _CB.onClickAnywhere.bind(this),\n                useCapture: true\n            },\n        ]\n\n        for( e of this.listeners.global )\n            e.target[action](e.type, e.cb, !!e.useCapture);\n    },\n\n    unbindGlobal() {\n        this.events.bindGlobal.call(this, true);\n    },\n\n    /**\n     * DOM events callbacks\n     */\n    callbacks : {\n        onFocusBlur(e){\n            // when focusing within a tag which is in edit-mode\n            var _s = this.settings,\n                nodeTag = isWithinNodeTag.call(this, e.relatedTarget),\n                targetIsTagNode = isNodeTag.call(this, e.relatedTarget),\n                isTargetXBtn = e.target.classList.contains(_s.classNames.tagX),\n                isFocused = e.type == 'focusin',\n                lostFocus = e.type == 'focusout';\n\n            // when focusing within a tag which is in edit-mode, only and specifically on the text-part of the tag node\n            // and not the X button or any other custom element thatmight be there\n            // var tagTextNode = e.target?.closest(this.settings.classNames.tagTextSelector)\n\n            if(isTargetXBtn && _s.mode != 'mix') {\n                this.DOM.input.focus()\n            }\n\n            if( nodeTag && isFocused && (!targetIsTagNode) && !isTargetXBtn) {\n                this.toggleFocusClass(this.state.hasFocus = +new Date())\n\n                // only if focused within a tag's text node should the `onEditTagFocus` function be called.\n                // if clicked anywhere else inside a tag, which had triggered an `focusin` event,\n                // the onFocusBlur should be aborted. This part was spcifically written for `select` mode.\n                // tagTextNode && this.events.callbacks.onEditTagFocus.call(this, nodeTag)\n            }\n\n            var text = e.target ? this.trim(this.DOM.input.textContent) : '', // a string\n                currentDisplayValue = this.value?.[0]?.[_s.tagTextProp],\n                ddEnabled = _s.dropdown.enabled >= 0,\n                eventData = {relatedTarget:e.relatedTarget},\n                isTargetSelectOption = this.state.actions.selectOption && (ddEnabled || !_s.dropdown.closeOnSelect),\n                isTargetAddNewBtn = this.state.actions.addNew && ddEnabled,\n                shouldAddTags;\n\n            if( lostFocus ){\n                if( e.relatedTarget === this.DOM.scope ){\n                    this.dropdown.hide()\n                    this.DOM.input.focus()\n                    return\n                }\n\n                this.postUpdate()\n                _s.onChangeAfterBlur && this.triggerChangeEvent()\n            }\n\n            if( isTargetSelectOption || isTargetAddNewBtn || isTargetXBtn ) {\n                return;\n            }\n\n            // should only loose focus at this point if the event was not generated from within a tag\n            if( isFocused || nodeTag ) {\n                this.state.hasFocus = +new Date()\n            }\n            else {\n                this.state.hasFocus = false;\n            }\n\n            this.toggleFocusClass(this.state.hasFocus)\n\n            if( _s.mode == 'mix' ){\n                if( isFocused ){\n                    this.trigger(\"focus\", eventData)\n                }\n\n                else if( lostFocus ){\n                    this.trigger(\"blur\", eventData)\n                    this.loading(false)\n                    this.dropdown.hide()\n                    // reset state which needs reseting\n                    this.state.dropdown.visible = undefined\n                    this.setStateSelection()\n                }\n\n                return\n            }\n\n            if( isFocused ){\n                if( !_s.focusable ) return;\n\n                var dropdownCanBeShown = _s.dropdown.enabled === 0 && !this.state.dropdown.visible,\n                    condition2 = !targetIsTagNode || _s.mode === 'select'\n\n                this.trigger(\"focus\", eventData)\n                //  e.target.classList.remove('placeholder');\n                if( dropdownCanBeShown && condition2 ){  // && _s.mode != \"select\"\n                    this.dropdown.show(this.value.length ? '' : undefined)\n                }\n\n                return\n            }\n\n            else if( lostFocus ){\n                this.trigger(\"blur\", eventData)\n                this.loading(false)\n\n                // when clicking the X button of a selected tag, it is unwanted for it to be added back\n                // again in a few more lines of code (shouldAddTags && addTags)\n                if( _s.mode == 'select' ) {\n                    if( this.value.length ) {\n                        let firstTagNode = this.getTagElms()[0];\n                        text = this.trim(firstTagNode.textContent)\n                    }\n\n                    // if nothing has changed (same display value), do not add a tag\n                    if( currentDisplayValue === text )\n                        text = ''\n                }\n\n                shouldAddTags = text && !this.state.actions.selectOption && _s.addTagOnBlur && _s.addTagOn.includes('blur');\n                // do not add a tag if \"selectOption\" action was just fired (this means a tag was just added from the dropdown)\n                shouldAddTags && this.addTags(text, true)\n            }\n\n            // when clicking a tag, do not consider this is a \"blur\" event\n            if ( !nodeTag )  {\n                this.DOM.input.removeAttribute('style')\n                this.dropdown.hide()\n            }\n        },\n\n        onCompositionStart(e){\n            this.state.composing = true\n        },\n\n        onCompositionEnd(e){\n            this.state.composing = false\n        },\n\n        onWindowKeyDown(e){\n            var _s = this.settings,\n                focusedElm = document.activeElement,\n                withinTag = isWithinNodeTag.call(this, focusedElm),\n                isBelong = withinTag && this.DOM.scope.contains(focusedElm),\n                isInputNode = focusedElm === this.DOM.input,\n                isReadyOnlyTag = isBelong && focusedElm.hasAttribute('readonly'),\n                nextTag;\n\n            if( !this.state.hasFocus && (!isBelong || isReadyOnlyTag) || isInputNode ) return;\n\n            nextTag = focusedElm.nextElementSibling;\n\n            var targetIsRemoveBtn = e.target.classList.contains(_s.classNames.tagX);\n\n            switch( e.key ){\n                // remove tag if has focus\n                case 'Backspace': {\n                    if( !_s.readonly && !this.state.editing ) {\n                        this.removeTags(focusedElm);\n                        (nextTag ? nextTag : this.DOM.input).focus()\n                    }\n\n                    break;\n                }\n\n                case 'Enter': {\n                    if( targetIsRemoveBtn ) {\n                        this.removeTags( e.target.parentNode )\n                        return\n                    }\n\n                    if( _s.a11y.focusableTags && isNodeTag.call(this, focusedElm) )\n                        setTimeout(this.editTag.bind(this), 0, focusedElm)\n\n                    break;\n                }\n\n                case 'ArrowDown' : {\n                    // if( _s.mode == 'select' ) // issue #333\n                    if( !this.state.dropdown.visible && _s.mode != 'mix' )\n                        this.dropdown.show()\n                    break;\n                }\n            }\n        },\n\n        onKeydown(e){\n            var _s = this.settings;\n\n            // ignore keys during IME composition or when user input is not allowed\n            if( this.state.composing || !_s.userInput )\n                return\n\n            if( _s.mode == 'select' && _s.enforceWhitelist && this.value.length && e.key != 'Tab' ){\n                e.preventDefault()\n            }\n\n            var s = this.trim(e.target.textContent);\n\n            this.trigger(\"keydown\", {event:e})\n\n            _s.hooks.beforeKeyDown(e, {tagify:this})\n                .then(result => {\n                    /**\n                     * ONLY FOR MIX-MODE:\n                     */\n                    if( _s.mode == 'mix' ){\n                        switch( e.key ){\n                            case 'Left' :\n                            case 'ArrowLeft' : {\n                                // when left arrow was pressed, set a flag so when the dropdown is shown, right-arrow will be ignored\n                                // because it seems likely the user wishes to use the arrows to move the caret\n                                this.state.actions.ArrowLeft = true\n                                break\n                            }\n\n                            case 'Delete':\n                            case 'Backspace' : {\n                                if( this.state.editing ) return\n\n                                var sel = document.getSelection(),\n                                    deleteKeyTagDetected = e.key == 'Delete' && sel.anchorOffset == (sel.anchorNode.length || 0),\n                                    prevAnchorSibling = sel.anchorNode.previousSibling,\n                                    isCaretAfterTag = sel.anchorNode.nodeType == 1 || !sel.anchorOffset && prevAnchorSibling && prevAnchorSibling.nodeType == 1 && sel.anchorNode.previousSibling,\n                                    lastInputValue = decode(this.DOM.input.innerHTML),\n                                    lastTagElems = this.getTagElms(),\n                                    isZWS = sel.anchorNode.length === 1 && sel.anchorNode.nodeValue == String.fromCharCode(8203),\n                                    //  isCaretInsideTag = sel.anchorNode.parentNode('.' + _s.classNames.tag),\n                                    tagBeforeCaret,\n                                    tagElmToBeDeleted,\n                                    firstTextNodeBeforeTag;\n\n                                if( _s.backspace == 'edit' && isCaretAfterTag ){\n                                    tagBeforeCaret = sel.anchorNode.nodeType == 1 ? null : sel.anchorNode.previousElementSibling;\n                                    setTimeout(this.editTag.bind(this), 0, tagBeforeCaret); // timeout is needed to the last cahacrter in the edited tag won't get deleted\n                                    e.preventDefault() // needed so the tag elm won't get deleted\n                                    return;\n                                }\n\n                                if( isChromeAndroidBrowser() && isCaretAfterTag instanceof Element ){\n                                    firstTextNodeBeforeTag = getfirstTextNode(isCaretAfterTag)\n\n                                    if( !isCaretAfterTag.hasAttribute('readonly') )\n                                        isCaretAfterTag.remove() // since this is Chrome, can safetly use this \"new\" DOM API\n\n                                    // Android-Chrome wrongly hides the keyboard, and loses focus,\n                                    // so this hack below is needed to regain focus at the correct place:\n                                    this.DOM.input.focus()\n                                    setTimeout(() => {\n                                        placeCaretAfterNode(firstTextNodeBeforeTag)\n                                        this.DOM.input.click()\n\n                                    })\n\n                                    return\n                                }\n\n                                if( sel.anchorNode.nodeName == 'BR')\n                                    return\n\n                                if( (deleteKeyTagDetected || isCaretAfterTag) && sel.anchorNode.nodeType == 1 )\n                                    if( sel.anchorOffset == 0 ) // caret is at the very begining, before a tag\n                                        tagElmToBeDeleted = deleteKeyTagDetected // delete key pressed\n                                            ? lastTagElems[0]\n                                            : null;\n                                    else\n                                        tagElmToBeDeleted = lastTagElems[Math.min(lastTagElems.length, sel.anchorOffset) - 1]\n\n                                // find out if a tag *might* be a candidate for deletion, and if so, which\n                                else if( deleteKeyTagDetected )\n                                    tagElmToBeDeleted = sel.anchorNode.nextElementSibling;\n\n                                else if( isCaretAfterTag instanceof Element )\n                                    tagElmToBeDeleted = isCaretAfterTag;\n\n                                // tagElm.hasAttribute('readonly')\n                                if( sel.anchorNode.nodeType == 3 &&   // node at caret location is a Text node\n                                    !sel.anchorNode.nodeValue    &&   // has some text\n                                    sel.anchorNode.previousElementSibling )  // text node has a Tag node before it\n                                    e.preventDefault()\n\n                                // if backspace not allowed, do nothing\n                                // TODO: a better way to detect if nodes were deleted is to simply check the \"this.value\" before & after\n                                if( (isCaretAfterTag || deleteKeyTagDetected) && !_s.backspace ){\n                                    e.preventDefault()\n                                    return\n                                }\n\n                                if( sel.type != 'Range' && !sel.anchorOffset && sel.anchorNode == this.DOM.input && e.key != 'Delete' ){\n                                    e.preventDefault()\n                                    return\n                                }\n\n                                if( sel.type != 'Range' && tagElmToBeDeleted && tagElmToBeDeleted.hasAttribute('readonly') ){\n                                    // allows the continuation of deletion by placing the caret on the first previous textNode.\n                                    // since a few readonly-tags might be one after the other, iteration is needed:\n\n                                    placeCaretAfterNode( getfirstTextNode(tagElmToBeDeleted) )\n                                    return\n                                }\n\n                                if ( e.key == 'Delete' && isZWS && getSetTagData(sel.anchorNode.nextSibling) ) {\n                                    this.removeTags(sel.anchorNode.nextSibling)\n                                }\n\n                                // update regarding https://github.com/yairEO/tagify/issues/762#issuecomment-786464317:\n                                // the bug described is more severe than the fix below, therefore I disable the fix until a solution\n                                // is found which work well for both cases.\n                                // -------\n                                // nodeType is \"1\" only when the caret is at the end after last tag (no text after), or before first first (no text before)\n                                /*\n                                if( this.isFirefox && sel.anchorNode.nodeType == 1 && sel.anchorOffset != 0 ){\n                                    this.removeTags() // removes last tag by default if no parameter supplied\n                                    // place caret inside last textNode, if exist. it's an annoying bug only in FF,\n                                    // if the last tag is removed, and there is a textNode before it, the caret is not placed at its end\n                                    placeCaretAfterNode( setRangeAtStartEnd(false, this.DOM.input) )\n                                }\n                                */\n\n                                break;\n                            }\n                            // currently commented to allow new lines in mixed-mode\n                            // case 'Enter' :\n                            //     // e.preventDefault(); // solves Chrome bug - http://stackoverflow.com/a/20398191/104380\n                        }\n\n                        return true\n                    }\n\n                    var isManualDropdown = _s.dropdown.position == 'manual';\n\n                    switch( e.key ){\n                        case 'Backspace' :\n                            if( _s.mode == 'select' && _s.enforceWhitelist && this.value.length)\n                                this.removeTags()\n\n                            else if( !this.state.dropdown.visible || _s.dropdown.position == 'manual' ){\n                                if( e.target.textContent == \"\" || s.charCodeAt(0) == 8203 ){  // 8203: ZERO WIDTH SPACE unicode\n                                    if( _s.backspace === true )\n                                        this.removeTags()\n                                    else if( _s.backspace == 'edit' )\n                                        setTimeout(this.editTag.bind(this), 0) // timeout reason: when edited tag gets focused and the caret is placed at the end, the last character gets deletec (because of backspace)\n                                }\n                            }\n                            break;\n\n                        case 'Esc' :\n                        case 'Escape' :\n                            if( this.state.dropdown.visible ) return\n                            e.target.blur()\n                            break;\n\n                        case 'Down' :\n                        case 'ArrowDown' :\n                            // if( _s.mode == 'select' ) // issue #333\n                            if( !this.state.dropdown.visible )\n                                this.dropdown.show()\n                            break;\n\n                        case 'ArrowRight' : {\n                            let tagData = this.state.inputSuggestion || this.state.ddItemData\n                            if( tagData && _s.autoComplete.rightKey ){\n                                this.addTags([tagData], true)\n                                return;\n                            }\n                            break\n                        }\n\n                        case 'Tab' : {\n                            return true;\n                        }\n\n                        case 'Enter' :\n                            // manual suggestion boxes are assumed to always be visible\n                            if( this.state.dropdown.visible && !isManualDropdown ) return\n                            e.preventDefault(); // solves Chrome bug - http://stackoverflow.com/a/20398191/104380\n                            // because the main \"keydown\" event is bound before the dropdown events, this will fire first and will not *yet*\n                            // know if an option was just selected from the dropdown menu. If an option was selected,\n                            // the dropdown events should handle adding the tag\n\n                            var thingToAdd = this.state.autoCompleteData || s;\n\n                            setTimeout(()=>{\n                                if( (!this.state.dropdown.visible || isManualDropdown) && !this.state.actions.selectOption && _s.addTagOn.includes(e.key.toLowerCase()) ) {\n                                    this.addTags([thingToAdd], true)\n                                    this.state.autoCompleteData = null\n                                }\n                            })\n                    }\n                })\n                .catch(err => err)\n        },\n\n        onInput(e){\n            this.postUpdate() // toggles \"tagify--empty\" class\n\n            var _s = this.settings;\n\n            if( _s.mode == 'mix' )\n                return this.events.callbacks.onMixTagsInput.call(this, e);\n\n            var value = this.input.normalize.call(this, undefined, {trim: false}),\n                showSuggestions = value.length >= _s.dropdown.enabled,\n                eventData = {value, inputElm:this.DOM.input},\n                validation = this.validateTag({value});\n\n            if( _s.mode == 'select' ) {\n                this.toggleScopeValidation(validation)\n            }\n\n            eventData.isValid = validation;\n\n            // for IE; since IE doesn't have an \"input\" event so \"keyDown\" is used instead to trigger the \"onInput\" callback,\n            // and so many keys do not change the input, and for those do not continue.\n            if( this.state.inputText == value ) return;\n\n            // save the value on the input's State object\n            this.input.set.call(this, value, false); // update the input with the normalized value and run validations\n            // this.setRangeAtStartEnd(false, this.DOM.input); // fix caret position\n\n            // if delimiters detected, add tags\n            if( value.search(_s.delimiters) != -1 ){\n                if( this.addTags( value ) ){\n                    this.input.set.call(this); // clear the input field's value\n                }\n            }\n\n            else if( _s.dropdown.enabled >= 0 ){\n                this.dropdown[showSuggestions ? \"show\" : \"hide\"](value);\n            }\n\n            this.trigger('input', eventData) // \"input\" event must be triggered at this point, before the dropdown is shown\n        },\n\n        onMixTagsInput( e ){\n            var rangeText, match, matchedPatternCount, tag, showSuggestions, selection,\n                _s = this.settings,\n                lastTagsCount = this.value.length,\n                matchFlaggedTag,\n                matchDelimiters,\n                tagsElems = this.getTagElms(),\n                fragment = document.createDocumentFragment(),\n                range = window.getSelection().getRangeAt(0),\n                remainingTagsValues = [].map.call(tagsElems, node => getSetTagData(node).value);\n\n            // Android Chrome \"keydown\" event argument does not report the correct \"key\".\n            // this workaround is needed to manually call \"onKeydown\" method with a synthesized event object\n            if( e.inputType == \"deleteContentBackward\" && isChromeAndroidBrowser() ){\n                this.events.callbacks.onKeydown.call(this, {\n                    target: e.target,\n                    key: \"Backspace\",\n                })\n            }\n\n            // if there's a tag as the first child of the input, always make sure it has a zero-width character before it\n            // or if two tags are next to each-other, add a zero-space width character (For the caret to appear)\n            fixCaretBetweenTags(this.getTagElms())\n\n            // re-add \"readonly\" tags which might have been removed\n            this.value.slice().forEach(item => {\n                if( item.readonly && !remainingTagsValues.includes(item.value) )\n                    fragment.appendChild( this.createTagElem(item) )\n            })\n\n            if( fragment.childNodes.length ){\n                range.insertNode(fragment)\n                this.setRangeAtStartEnd(false, fragment.lastChild)\n            }\n\n            // check if tags were \"magically\" added/removed (browser redo/undo or CTRL-A -> delete)\n            if( tagsElems.length != lastTagsCount ){\n                this.value = [].map.call(this.getTagElms(), node => getSetTagData(node))\n                this.update({ withoutChangeEvent:true })\n                return\n            }\n\n            if( this.hasMaxTags() )\n                return true\n\n            if( window.getSelection ){\n                selection = window.getSelection()\n\n                // only detect tags if selection is inside a textNode (not somehow on already-existing tag)\n                if( selection.rangeCount > 0 && selection.anchorNode.nodeType == 3 ){\n                    range = selection.getRangeAt(0).cloneRange()\n                    range.collapse(true)\n                    range.setStart(selection.focusNode, 0)\n\n                    rangeText = range.toString().slice(0, range.endOffset)  // slice the range so everything AFTER the caret will be trimmed\n                    // split = range.toString().split(_s.mixTagsAllowedAfter)  // [\"foo\", \"bar\", \"@baz\"]\n                    matchedPatternCount = rangeText.split(_s.pattern).length - 1;\n\n                    match = rangeText.match( _s.pattern )\n\n                    if( match )\n                        // tag string, example: \"@aaa ccc\"\n                        tag = rangeText.slice( rangeText.lastIndexOf(match[match.length-1]) )\n\n                    if( tag ){\n                        this.state.actions.ArrowLeft = false // start fresh, assuming the user did not (yet) used any arrow to move the caret\n                        this.state.tag = {\n                            prefix : tag.match(_s.pattern)[0],\n                            value  : tag.replace(_s.pattern, ''), // get rid of the prefix\n                        }\n                        this.state.tag.baseOffset = selection.baseOffset - this.state.tag.value.length\n\n                        matchDelimiters = this.state.tag.value.match(_s.delimiters)\n                        // if a delimeter exists, add the value as tag (exluding the delimiter)\n                        if( matchDelimiters ){\n                            this.state.tag.value = this.state.tag.value.replace(_s.delimiters, '')\n                            this.state.tag.delimiters = matchDelimiters[0]\n                            this.addTags(this.state.tag.value, _s.dropdown.clearOnSelect)\n                            this.dropdown.hide()\n                            return\n                        }\n\n                        showSuggestions = this.state.tag.value.length >= _s.dropdown.enabled\n\n                        // When writing something that might look like a tag (an email address) but isn't one - it is unwanted\n                        // the suggestions dropdown be shown, so the user can close it (in any way), and while continue typing,\n                        // dropdown should stay closed until another tag is typed.\n                        // if( this.state.tag.value.length && this.state.dropdown.visible === false )\n                        //     showSuggestions = false\n\n                        // test for similar flagged tags to the current tag\n\n                        try{\n                            matchFlaggedTag = this.state.flaggedTags[this.state.tag.baseOffset]\n                            matchFlaggedTag = matchFlaggedTag.prefix   == this.state.tag.prefix &&\n                                              matchFlaggedTag.value[0] == this.state.tag.value[0]\n\n                            // reset\n                            if( this.state.flaggedTags[this.state.tag.baseOffset] && !this.state.tag.value )\n                                delete this.state.flaggedTags[this.state.tag.baseOffset];\n                        }\n                        catch(err){}\n\n                        // scenario: (do not show suggestions of another matched tag, if more than one detected)\n                        // (2 tags exist)                          \" a@a.com and @\"\n                        // (second tag is removed by backspace)    \" a@a.com and \"\n                        if( matchFlaggedTag || matchedPatternCount < this.state.mixMode.matchedPatternCount )\n                            showSuggestions = false\n                    }\n                    // no (potential) tag found\n                    else{\n                        this.state.flaggedTags = {}\n                    }\n\n                    this.state.mixMode.matchedPatternCount = matchedPatternCount\n                }\n            }\n\n\n            // wait until the \"this.value\" has been updated (see \"onKeydown\" method for \"mix-mode\")\n            // the dropdown must be shown only after this event has been triggered, so an implementer could\n            // dynamically change the whitelist.\n            setTimeout(()=>{\n                this.update({withoutChangeEvent:true})\n                this.trigger('input', extend({}, this.state.tag, {textContent:this.DOM.input.textContent}))\n\n                if( this.state.tag )\n                    this.dropdown[showSuggestions ? \"show\" : \"hide\"](this.state.tag.value);\n            }, 10)\n        },\n\n        onInputIE(e){\n            var _this = this;\n            // for the \"e.target.textContent\" to be changed, the browser requires a small delay\n            setTimeout(function(){\n                _this.events.callbacks.onInput.call(_this, e)\n            })\n        },\n\n        observeOriginalInputValue(){\n            // if, for some reason, the Tagified element is no longer in the DOM,\n            // call the \"destroy\" method to kill all references to timeouts/intervals\n            if( !this.DOM.originalInput.parentNode ) this.destroy()\n\n            // if original input value changed for some reason (for exmaple a form reset)\n            if( this.DOM.originalInput.value != this.DOM.originalInput.tagifyValue )\n                this.loadOriginalValues()\n        },\n\n        onClickAnywhere(e){\n            if (e.target != this.DOM.scope && !this.DOM.scope.contains(e.target)) {\n                this.toggleFocusClass(false)\n                this.state.hasFocus = false\n\n                let closestTagifyDropdownElem = e.target.closest(this.settings.classNames.dropdownSelector);\n\n                // do not hide the dropdown if a click was initiated within it and that dropdown belongs to this Tagify instance\n                if( closestTagifyDropdownElem?.__tagify != this )\n                    this.dropdown.hide()\n            }\n        },\n\n        onClickScope(e){\n            var _s = this.settings,\n                tagElm = e.target.closest('.' + _s.classNames.tag),\n                isScope = e.target === this.DOM.scope,\n                timeDiffFocus = +new Date() - this.state.hasFocus;\n\n            if( isScope && _s.mode != 'select' ){\n                // if( !this.state.hasFocus )\n                    this.DOM.input.focus()\n                return\n            }\n\n            else if( e.target.classList.contains(_s.classNames.tagX) ){\n                this.removeTags( e.target.parentNode )\n                return\n            }\n\n            else if( tagElm && !this.state.editing ){\n                this.trigger(\"click\", { tag:tagElm, index:this.getNodeIndex(tagElm), data:getSetTagData(tagElm), event:e })\n\n                if( _s.editTags === 1 || _s.editTags.clicks === 1 || _s.mode == 'select' )\n                    this.events.callbacks.onDoubleClickScope.call(this, e)\n\n                return\n            }\n\n            // when clicking on the input itself\n            else if( e.target == this.DOM.input ){\n                if( _s.mode == 'mix' ){\n                    // firefox won't show caret if last element is a tag (and not a textNode),\n                    // so an empty textnode should be added\n                    this.fixFirefoxLastTagNoCaret()\n                }\n\n                if( timeDiffFocus > 500 || !_s.focusable ){\n                    if( this.state.dropdown.visible )\n                        this.dropdown.hide()\n                    else if( _s.dropdown.enabled === 0 && _s.mode != 'mix' )\n                        this.dropdown.show(this.value.length ? '' : undefined)\n                    return\n                }\n            }\n\n            if( _s.mode == 'select' && _s.dropdown.enabled === 0 && !this.state.dropdown.visible) {\n                this.events.callbacks.onDoubleClickScope.call(this, {...e, target: this.getTagElms()[0]})\n\n                !_s.userInput && this.dropdown.show()\n            }\n        },\n\n        // special proccess is needed for pasted content in order to \"clean\" it\n        onPaste(e){\n            e.preventDefault()\n\n            var tagsElems,\n                _s = this.settings,\n                selectModeWithoutInput =_s.mode == 'select' && _s.enforceWhitelist;\n\n            if( selectModeWithoutInput || !_s.userInput ){\n                return false;\n            }\n\n            var clipboardData, pastedText;\n\n            if( _s.readonly ) return\n\n            // Get pasted data via clipboard API\n            clipboardData = e.clipboardData || window.clipboardData\n            pastedText = clipboardData.getData('Text')\n\n            _s.hooks.beforePaste(e, {tagify:this, pastedText, clipboardData})\n                .then(result => {\n                    if( result === undefined )\n                        result = pastedText;\n\n                    if( result ){\n                        this.injectAtCaret(result, window.getSelection().getRangeAt(0))\n\n                        if( this.settings.mode == 'mix' ){\n                            this.events.callbacks.onMixTagsInput.call(this, e);\n                        }\n\n                        else if( this.settings.pasteAsTags ){\n                            tagsElems = this.addTags(this.state.inputText + result, true)\n                        }\n\n                        else {\n                            this.state.inputText = result\n                            this.dropdown.show(result)\n                        }\n                    }\n\n                    this.trigger('paste', {event: e, pastedText, clipboardData, tagsElems})\n                })\n                .catch(err => err)\n        },\n\n        onDrop(e){\n            e.preventDefault()\n        },\n\n        onEditTagInput( editableElm, e ){\n            var tagElm = editableElm.closest('.' + this.settings.classNames.tag),\n                tagElmIdx = this.getNodeIndex(tagElm),\n                tagData = getSetTagData(tagElm),\n                textValue = this.input.normalize.call(this, editableElm),\n                dataForChangedProp = {[this.settings.tagTextProp]: textValue, __tagId: tagData.__tagId}, // \"__tagId\" is needed so validation will skip current tag when checking for dups\n                isValid = this.validateTag(dataForChangedProp), // the value could have been invalid in the first-place so make sure to re-validate it (via \"addEmptyTag\" method)\n                hasChanged = this.editTagChangeDetected(extend(tagData, dataForChangedProp));\n\n            // if the value is same as before-editing and the tag was valid before as well, ignore the  current \"isValid\" result, which is false-positive\n            if( !hasChanged && editableElm.originalIsValid === true )\n                isValid = true\n\n            tagElm.classList.toggle(this.settings.classNames.tagInvalid, isValid !== true)\n            tagData.__isValid = isValid\n\n            tagElm.title = isValid === true\n                ? tagData.title || tagData.value\n                : isValid // change the tag's title to indicate why is the tag invalid (if it's so)\n\n            // show dropdown if typed text is equal or more than the \"enabled\" dropdown setting\n            if( textValue.length >= this.settings.dropdown.enabled ){\n                // this check is needed apparently because doing browser \"undo\" will fire\n                //  \"onEditTagInput\" but \"this.state.editing\" will be \"false\"\n                if( this.state.editing )\n                    this.state.editing.value = textValue\n                this.dropdown.show(textValue)\n            }\n\n            this.trigger(\"edit:input\", {\n                tag  : tagElm,\n                index: tagElmIdx,\n                data : extend({}, this.value[tagElmIdx], {newValue:textValue}),\n                event: e\n            })\n        },\n\n        onEditTagPaste( tagElm, e ){\n            // Get pasted data via clipboard API\n            var clipboardData = e.clipboardData || window.clipboardData,\n                pastedText = clipboardData.getData('Text');\n\n            e.preventDefault()\n\n            var newNode = injectAtCaret(pastedText)\n            this.setRangeAtStartEnd(false, newNode)\n        },\n\n        onEditTagClick( tagElm, e) {\n            this.events.callbacks.onClickScope.call(this, e)\n        },\n\n        onEditTagFocus( tagElm ){\n            this.state.editing = {\n                scope: tagElm,\n                input: tagElm.querySelector(\"[contenteditable]\")\n            }\n        },\n\n        onEditTagBlur( editableElm, e ){\n            // if \"relatedTarget\" is the tag then do not continue as this should not be considered a \"blur\" event\n            var isRelatedTargetNodeTag = isNodeTag.call(this, e.relatedTarget)\n\n            // in \"select-mode\" when editing the tag's template to include more nodes other than the editable \"span\",\n            // clicking those elements should not be considered a blur event\n            if( this.settings.mode == 'select' && isRelatedTargetNodeTag && e.relatedTarget.contains(e.target) ) {\n                this.dropdown.hide()\n                return\n            }\n\n            // if \"ESC\" key was pressed then the \"editing\" state should be `false` and if so, logic should not continue\n            // because \"ESC\" reverts the edited tag back to how it was (replace the node) before editing\n            if( !this.state.editing )\n                return;\n\n            if( !this.state.hasFocus )\n                this.toggleFocusClass()\n\n            if(!this.DOM.scope.contains(document.activeElement)) {\n                this.trigger(\"blur\", {})\n            }\n\n            // one scenario is when selecting a suggestion from the dropdown, when editing, and by selecting it\n            // the \"onEditTagDone\" is called directly, already replacing the tag, so the argument \"editableElm\"\n            // node isn't in the DOM anynmore because it has been replaced.\n            if( !this.DOM.scope.contains(editableElm) ) return;\n\n            var _s           = this.settings,\n                tagElm       = editableElm.closest('.' + _s.classNames.tag),\n                tagData      = getSetTagData(tagElm),\n                textValue    = this.input.normalize.call(this, editableElm),\n                dataForChangedProp = {[_s.tagTextProp]: textValue, __tagId: tagData.__tagId}, // \"__tagId\" is needed so validation will skip current tag when checking for dups\n                originalData = tagData.__originalData, // pre-edit data\n                hasChanged   = this.editTagChangeDetected(extend(tagData, dataForChangedProp)),\n                isValid      = this.validateTag(dataForChangedProp), // \"__tagId\" is needed so validation will skip current tag when checking for dups\n                hasMaxTags,\n                newTagData;\n\n            if( !textValue ){\n                this.onEditTagDone(tagElm)\n                return\n            }\n\n            // if nothing changed revert back to how it was before editing\n            if( !hasChanged ){\n                this.onEditTagDone(tagElm, originalData)\n                return\n            }\n\n            // need to know this because if \"keepInvalidTags\" setting is \"true\" and an invalid tag is edited as a valid one,\n            // but the maximum number of tags have alreay been reached, so it should not allow saving the new valid value.\n            // only if the tag was already valid before editing, ignore this check (see a few lines below)\n            hasMaxTags = this.hasMaxTags()\n\n            newTagData = extend(\n                {},\n                originalData,\n                {\n                    [_s.tagTextProp]: this.trim(textValue),\n                    __isValid: isValid\n                }\n            )\n\n            // pass through optional transformer defined in settings\n            _s.transformTag.call(this, newTagData, originalData)\n\n            // MUST re-validate after tag transformation\n            // only validate the \"tagTextProp\" because is the only thing that metters for validating an edited tag.\n            // -- Scenarios: --\n            // 1. max 3 tags allowd. there are 4 tags, one has invalid input and is edited to a valid one, and now should be marked as \"not allowed\" because limit of tags has reached\n            // 2. max 3 tags allowed. there are 3 tags, one is edited, and so max-tags vaildation should be OK\n            isValid = (!hasMaxTags || originalData.__isValid === true) && this.validateTag(newTagData)\n\n            if( isValid !== true ){\n                this.trigger(\"invalid\", { data:newTagData, tag:tagElm, message:isValid })\n\n                // do nothing if invalid, stay in edit-mode until corrected or reverted by presssing esc\n                if( _s.editTags.keepInvalid ) return\n\n                if( _s.keepInvalidTags )\n                    newTagData.__isValid = isValid\n                else\n                    // revert back if not specified to keep\n                    newTagData = originalData\n            }\n\n            else if( _s.keepInvalidTags ){\n                // cleaup any previous leftovers if the tag was invalid\n                delete newTagData.title\n                delete newTagData[\"aria-invalid\"]\n                delete newTagData.class\n            }\n\n            // tagElm.classList.toggle(_s.classNames.tagInvalid, true)\n\n            this.onEditTagDone(tagElm, newTagData)\n        },\n\n        onEditTagkeydown(e, tagElm){\n            // ignore keys during IME composition\n            if( this.state.composing )\n                return\n\n            this.trigger(\"edit:keydown\", {event:e})\n\n            switch( e.key ){\n                case 'Esc' :\n                case 'Escape' : {\n                    this.state.editing = false\n                    var hasValueToRevertTo = !!tagElm.__tagifyTagData.__originalData.value\n\n                    if( hasValueToRevertTo )\n                        // revert the tag to how it was before editing\n                        // replace current tag with original one (pre-edited one)\n                        tagElm.parentNode.replaceChild(tagElm.__tagifyTagData.__originalHTML, tagElm)\n                    else\n                        tagElm.remove()\n\n                    break\n                }\n                case 'Enter' :\n                case 'Tab' : {\n                    e.preventDefault()\n\n                    var EDITED_TAG_BLUR_DELAY = 0;\n\n                    // a setTimeout is used so when editing (in \"select\" mode) while the dropdown is shown and a suggestion is highlighted\n                    // and ENTER key is pressed down - the `dropdown.hide` method won't be invoked immediately and unbind the dropdown's\n                    // KEYDOWN \"ENTER\" before it has time to call the handler and select the suggestion.\n                    setTimeout(() => e.target.blur(), EDITED_TAG_BLUR_DELAY)\n                }\n            }\n        },\n\n        onDoubleClickScope(e){\n            var tagElm = e.target.closest('.' + this.settings.classNames.tag),\n                tagData = getSetTagData(tagElm),\n                _s = this.settings,\n                isEditingTag,\n                isReadyOnlyTag;\n\n            if( !tagElm || tagData.editable === false ) return\n\n            isEditingTag = tagElm.classList.contains(this.settings.classNames.tagEditing)\n            isReadyOnlyTag = tagElm.hasAttribute('readonly')\n\n            if( !_s.readonly && !isEditingTag && !isReadyOnlyTag && this.settings.editTags && _s.userInput ) {\n                this.events.callbacks.onEditTagFocus.call(this, tagElm)\n                this.editTag(tagElm)\n            }\n\n            this.toggleFocusClass(true)\n\n            if( _s.mode != 'select' )\n                this.trigger('dblclick', { tag:tagElm, index:this.getNodeIndex(tagElm), data:getSetTagData(tagElm) })\n        },\n\n        /**\n         *\n         * @param {Object} m an object representing the observed DOM changes\n         */\n        onInputDOMChange(m){\n            // iterate all DOM mutation\n            m.forEach(record => {\n                // only the ADDED nodes\n                record.addedNodes.forEach(addedNode => {\n                    // fix chrome's placing '<div><br></div>' everytime ENTER key is pressed, and replace with just `<br'\n                    if( addedNode.outerHTML == '<div><br></div>' ){\n                        addedNode.replaceWith(document.createElement('br'))\n                    }\n\n                    // if the added element is a div containing a tag within it (chrome does this when pressing ENTER before a tag)\n                    else if( addedNode.nodeType == 1 && addedNode.querySelector(this.settings.classNames.tagSelector) ){\n                        let newlineText = document.createTextNode('')\n\n                        if( addedNode.childNodes[0].nodeType == 3 && addedNode.previousSibling.nodeName != 'BR' )\n                            newlineText  = document.createTextNode('\\n')\n\n                        // unwrap the useless div\n                        // chrome adds a BR at the end which should be removed\n                        addedNode.replaceWith(...[newlineText, ...[...addedNode.childNodes].slice(0,-1)])\n                        placeCaretAfterNode(newlineText)\n                    }\n\n                    // if this is a tag\n                    else if( isNodeTag.call(this, addedNode) ){\n                        if( addedNode.previousSibling?.nodeType == 3 && !addedNode.previousSibling.textContent )\n                            addedNode.previousSibling.remove()\n\n                        // and it is the first node in a new line\n                        if( addedNode.previousSibling && addedNode.previousSibling.nodeName == 'BR' ){\n                            // allows placing the caret just before the tag, when the tag is the first node in that line\n                            addedNode.previousSibling.replaceWith('\\n' + ZERO_WIDTH_CHAR)\n\n                            let nextNode = addedNode.nextSibling, anythingAfterNode = '';\n\n                            while (nextNode) {\n                                anythingAfterNode += nextNode.textContent\n                                nextNode = nextNode.nextSibling;\n                            }\n\n                            // when hitting ENTER for new line just before an existing tag, but skip below logic when a tag has been addded\n                            anythingAfterNode.trim() && placeCaretAfterNode(addedNode.previousSibling)\n                        }\n\n                        // if previous sibling does not exists (meanning the addedNode is the first node in this.DOM.input)\n                        // or, if the previous sibling is also a tag, add a zero-space character before (to allow showing the caret in Chrome)\n                        else if( !addedNode.previousSibling || getSetTagData(addedNode.previousSibling) ){\n                            addedNode.before(ZERO_WIDTH_CHAR)\n                        }\n                    }\n                })\n\n                record.removedNodes.forEach(removedNode => {\n                    // when trying to delete a tag which is in a new line and there's nothing else there (caret is after the tag)\n                    if( removedNode && removedNode.nodeName == 'BR' && isNodeTag.call(this, lastInputChild)){\n                        this.removeTags(lastInputChild)\n                        this.fixFirefoxLastTagNoCaret()\n                    }\n                })\n            })\n\n            // get the last child only after the above DOM modifications\n            // check these scenarios:\n            // 1. after a single line, press ENTER once - should add only 1 BR\n            // 2. presss ENTER right before a tag\n            // 3. press enter within a text node before a tag\n            var lastInputChild = this.DOM.input.lastChild;\n\n            if( lastInputChild && lastInputChild.nodeValue == '' )\n                lastInputChild.remove()\n\n            // make sure the last element is always a BR\n            if( !lastInputChild || lastInputChild.nodeName != 'BR' ){\n                this.DOM.input.appendChild(document.createElement('br'))\n            }\n        },\n    }\n}\n\n", "import { sameStr, removeCollectionProp, omit, isObject, parseHTML, removeTextChildNodes, escapeHTML, extend, concatWithoutDups, getUID, isNodeTag, injectAtCaret, placeCaretAfterNode, getSetTagData, fixCaretBetweenTags, logger } from './parts/helpers'\nimport DEFAULTS from './parts/defaults'\nimport _dropdown, { initDropdown } from './parts/dropdown'\nimport { getPersistedData, setPersistedData, clearPersistedData } from './parts/persist'\nimport TEXTS from './parts/texts'\nimport templates from './parts/templates'\nimport EventDispatcher from './parts/EventDispatcher'\nimport events, { triggerChangeEvent } from './parts/events'\n\n/**\n * @constructor\n * @param {Object} input    DOM element\n * @param {Object} settings settings object\n */\nfunction Tagify( input, settings ){\n    if( !input ){\n        logger.warn('input element not found', input)\n        // return an empty mock of all methods, so the code using tagify will not break\n        // because it might be calling methods even though the input element does not exist\n        const mockInstance = new Proxy(this, { get(){ return () => mockInstance } })\n        return mockInstance\n    }\n\n    if( input.__tagify ){\n        logger.warn('input element is already Tagified - Same instance is returned.', input)\n        return input.__tagify\n    }\n\n    extend(this, EventDispatcher(this))\n    this.isFirefox = (/firefox|fxios/i).test(navigator.userAgent) && !(/seamonkey/i).test(navigator.userAgent)\n    this.isIE = window.document.documentMode; // https://developer.mozilla.org/en-US/docs/Web/API/Document/compatMode#Browser_compatibility\n\n    settings = settings || {};\n    this.getPersistedData = getPersistedData(settings.id)\n    this.setPersistedData = setPersistedData(settings.id)\n    this.clearPersistedData = clearPersistedData(settings.id)\n    this.applySettings(input, settings)\n\n    this.state = {\n        inputText: '',\n        editing : false,\n        composing: false,\n        actions : {},   // UI actions for state-locking\n        mixMode : {},\n        dropdown: {},\n        flaggedTags: {} // in mix-mode, when a string is detetced as potential tag, and the user has chocen to close the suggestions dropdown, keep the record of the tasg here\n    }\n\n    this.value = [] // tags' data\n\n    // events' callbacks references will be stores here, so events could be unbinded\n    this.listeners = {}\n\n    this.DOM = {} // Store all relevant DOM elements in an Object\n\n    this.build(input)\n    initDropdown.call(this)\n\n    this.getCSSVars()\n    this.loadOriginalValues()\n\n    this.events.customBinding.call(this)\n    this.events.binding.call(this)\n    input.autofocus && this.DOM.input.focus()\n    input.__tagify = this\n}\n\nTagify.prototype = {\n    _dropdown,\n    placeCaretAfterNode,\n    getSetTagData,\n    helpers: {sameStr, removeCollectionProp, omit, isObject, parseHTML, escapeHTML, extend, concatWithoutDups, getUID, isNodeTag},\n\n    customEventsList : ['change', 'add', 'remove', 'invalid', 'input', 'paste', 'click', 'keydown', 'focus', 'blur', 'edit:input', 'edit:beforeUpdate', 'edit:updated', 'edit:start', 'edit:keydown', 'dropdown:show', 'dropdown:hide', 'dropdown:select', 'dropdown:updated', 'dropdown:noMatch', 'dropdown:scroll'],\n    dataProps: ['__isValid', '__removed', '__originalData', '__originalHTML', '__tagId'], // internal-uasge props\n\n    trim(text){\n        return this.settings.trim && text && typeof text == \"string\" ? text.trim() : text\n    },\n\n    // expose this handy utility function\n    parseHTML,\n\n    templates,\n\n    parseTemplate(template, data){\n        template = this.settings.templates[template] || template;\n        return parseHTML( template.apply(this, data) )\n    },\n\n    set whitelist( arr ){\n        const isArray = arr && Array.isArray(arr)\n        this.settings.whitelist = isArray ? arr : []\n        this.setPersistedData(isArray ? arr : [], 'whitelist')\n    },\n\n    get whitelist(){\n        return this.settings.whitelist\n    },\n\n    set userInput( state ){\n        this.settings.userInput = !!state\n        this.setContentEditable(!!state)\n    },\n\n    get userInput(){\n        return this.settings.userInput\n    },\n\n    generateClassSelectors(classNames){\n        for( let name in classNames ) {\n            let currentName = name;\n            Object.defineProperty(classNames, currentName + \"Selector\" , {\n                get(){ return \".\" + this[currentName].split(\" \")[0] }\n            })\n        }\n    },\n\n    applySettings( input, settings ){\n        DEFAULTS.templates = this.templates\n\n        var mixModeDefaults = {\n            dropdown: {\n                position: \"text\"\n            }\n        }\n\n        var mergedDefaults = extend({}, DEFAULTS, (settings.mode == 'mix' ? mixModeDefaults : {}));\n        var _s = this.settings = extend({}, mergedDefaults, settings)\n\n        _s.disabled = input.hasAttribute('disabled')\n        _s.readonly = _s.readonly || input.hasAttribute('readonly')\n        _s.placeholder = escapeHTML(input.getAttribute('placeholder') || _s.placeholder || \"\")\n        _s.required = input.hasAttribute('required')\n\n        this.generateClassSelectors(_s.classNames)\n\n        if ( _s.dropdown.includeSelectedTags === undefined )\n            _s.dropdown.includeSelectedTags = _s.duplicates;\n\n        if( this.isIE )\n            _s.autoComplete = false; // IE goes crazy if this isn't false\n\n        [\"whitelist\", \"blacklist\"].forEach(name => {\n            var attrVal = input.getAttribute('data-' + name)\n            if( attrVal ){\n                attrVal = attrVal.split(_s.delimiters)\n                if( attrVal instanceof Array )\n                    _s[name] = attrVal\n            }\n        })\n\n        // backward-compatibility for old version of \"autoComplete\" setting:\n        if( \"autoComplete\" in settings && !isObject(settings.autoComplete) ){\n            _s.autoComplete = DEFAULTS.autoComplete\n            _s.autoComplete.enabled = settings.autoComplete\n        }\n\n        if( _s.mode == 'mix' ){\n            _s.pattern = _s.pattern || /@/;\n            _s.autoComplete.rightKey = true\n            _s.delimiters = settings.delimiters || null // default dlimiters in mix-mode must be NULL\n\n            // needed for \"filterListItems\". This assumes the user might have forgotten to manually\n            // define the same term in \"dropdown.searchKeys\" as defined in \"tagTextProp\" setting, so\n            // by automatically adding it, tagify is \"helping\" out, guessing the intesntions of the developer.\n            if( _s.tagTextProp && !_s.dropdown.searchKeys.includes(_s.tagTextProp) )\n                _s.dropdown.searchKeys.push(_s.tagTextProp)\n        }\n\n        if( input.pattern )\n            try { _s.pattern = new RegExp(input.pattern)  }\n            catch(e){}\n\n        // Convert the \"delimiters\" setting into a REGEX object\n        if( _s.delimiters ){\n            _s._delimiters = _s.delimiters;\n            try { _s.delimiters = new RegExp(this.settings.delimiters, \"g\") }\n            catch(e){}\n        }\n\n        if( _s.disabled )\n            _s.userInput = false;\n\n        this.TEXTS = {...TEXTS, ...(_s.texts || {})}\n\n        // make sure the dropdown will be shown on \"focus\" and not only after typing something (in \"select\" mode)\n        if( (_s.mode == 'select' && !settings.dropdown?.enabled) || !_s.userInput ){\n            _s.dropdown.enabled = 0\n        }\n\n        _s.dropdown.appendTarget = settings.dropdown?.appendTarget || document.body;\n\n\n        // get & merge persisted data with current data\n        let persistedWhitelist = this.getPersistedData('whitelist');\n\n        if( Array.isArray(persistedWhitelist))\n            this.whitelist = Array.isArray(_s.whitelist)\n                ? concatWithoutDups(_s.whitelist, persistedWhitelist)\n                : persistedWhitelist;\n    },\n\n    /**\n     * Returns a string of HTML element attributes\n     * @param {Object} data [Tag data]\n     */\n    getAttributes( data ){\n        var attrs = this.getCustomAttributes(data), s = '', k;\n\n        for( k in attrs )\n            s += \" \" + k + (data[k] !== undefined ? `=\"${attrs[k]}\"` : \"\");\n\n        return s;\n    },\n\n    /**\n     * Returns an object of attributes to be used for the templates\n     */\n    getCustomAttributes( data ){\n        // only items which are objects have properties which can be used as attributes\n        if( !isObject(data) )\n            return '';\n\n        var output = {}, propName;\n\n        for( propName in data ){\n            if( propName.slice(0,2) != '__' && propName != 'class' && data.hasOwnProperty(propName) && data[propName] !== undefined )\n                output[propName] = escapeHTML(data[propName])\n        }\n        return output\n    },\n\n    setStateSelection(){\n        var selection = window.getSelection()\n\n        // save last selection place to be able to inject anything from outside to that specific place\n        var sel = {\n            anchorOffset: selection.anchorOffset,\n            anchorNode  : selection.anchorNode,\n            range       : selection.getRangeAt && selection.rangeCount && selection.getRangeAt(0)\n        }\n\n        this.state.selection = sel\n        return sel\n    },\n\n    /**\n     * Get specific CSS variables which are relevant to this script and parse them as needed.\n     * The result is saved on the instance in \"this.CSSVars\"\n     */\n    getCSSVars(){\n        var compStyle = getComputedStyle(this.DOM.scope, null)\n\n        const getProp = name => compStyle.getPropertyValue('--'+name)\n\n        function seprateUnitFromValue(a){\n            if( !a ) return {}\n            a = a.trim().split(' ')[0]\n            var unit  = a.split(/\\d+/g).filter(n=>n).pop().trim(),\n                value = +a.split(unit).filter(n=>n)[0].trim()\n            return {value, unit}\n        }\n\n        this.CSSVars = {\n            tagHideTransition: (({value, unit}) => unit=='s' ? value * 1000 : value)(seprateUnitFromValue(getProp('tag-hide-transition')))\n        }\n    },\n\n    /**\n     * builds the HTML of this component\n     * @param  {Object} input [DOM element which would be \"transformed\" into \"Tags\"]\n     */\n    build( input ){\n        var DOM  = this.DOM,\n            labelWrapper = input.closest('label');\n\n        if( this.settings.mixMode.integrated ){\n            DOM.originalInput = null;\n            DOM.scope = input;\n            DOM.input = input;\n        }\n\n        else {\n            DOM.originalInput = input\n            DOM.originalInput_tabIndex = input.tabIndex\n            DOM.scope = this.parseTemplate('wrapper', [input, this.settings])\n            DOM.input = DOM.scope.querySelector(this.settings.classNames.inputSelector)\n            input.parentNode.insertBefore(DOM.scope, input)\n            input.tabIndex = -1; // do not allow focus or typing directly, once tagified\n        }\n\n        // fixes tagify nested inside a <label> tag from getting focus when clicked on\n        if( labelWrapper )\n            labelWrapper.setAttribute('for', '')\n    },\n\n    /**\n     * revert any changes made by this component\n     */\n    destroy(){\n        this.events.unbindGlobal.call(this)\n        this.DOM.scope.parentNode?.removeChild(this.DOM.scope)\n        this.DOM.originalInput.tabIndex = this.DOM.originalInput_tabIndex\n        delete this.DOM.originalInput.__tagify\n        this.dropdown.hide(true)\n        this.removeAllCustomListeners()\n        clearTimeout(this.dropdownHide__bindEventsTimeout)\n        clearInterval(this.listeners.main.originalInputValueObserverInterval)\n    },\n\n    /**\n     * if the original input has any values, add them as tags\n     */\n    loadOriginalValues( value ){\n        var lastChild,\n            _s = this.settings\n\n        // temporarily block firing the \"change\" event on the original input until\n        // this method finish removing current value and adding a new one\n        this.state.blockChangeEvent = true\n\n        if( value === undefined ){\n            const persistedOriginalValue = this.getPersistedData('value')\n\n            // if the field already has a field, trust its the desired\n            // one to be rendered and do not use the persisted one\n            if( persistedOriginalValue && !this.DOM.originalInput.value )\n                value = persistedOriginalValue\n            else\n                value = _s.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value\n        }\n\n        this.removeAllTags()\n\n        if( value ){\n            if( _s.mode == 'mix' ){\n                this.parseMixTags(value)\n\n                lastChild = this.DOM.input.lastChild\n\n                // fixes a Chrome bug, when the last node in `mix-mode` is a tag, the caret appears at the far-top-top, outside the field\n                if( !lastChild || lastChild.tagName != 'BR' )\n                    this.DOM.input.insertAdjacentHTML('beforeend', '<br>')\n            }\n\n            else{\n                try{\n                    if( JSON.parse(value) instanceof Array )\n                        value = JSON.parse(value)\n                }\n                catch(err){}\n                this.addTags(value, true).forEach(tag => tag && tag.classList.add(_s.classNames.tagNoAnimation))\n            }\n        }\n\n        else\n            this.postUpdate()\n\n        this.state.lastOriginalValueReported = _s.mixMode.integrated ? '' : this.DOM.originalInput.value\n    },\n\n    cloneEvent(e){\n        var clonedEvent = {}\n        for( var v in e )\n            if( v != 'path' )\n                clonedEvent[v] = e[v]\n        return clonedEvent\n    },\n\n    /**\n     * Toogle global loading state on/off\n     * Useful when fetching async whitelist while user is typing\n     * @param {Boolean} isLoading\n     */\n    loading( isLoading ){\n        this.state.isLoading = isLoading\n        // IE11 doesn't support toggle with second parameter\n        this.DOM.scope.classList[isLoading ? \"add\" : \"remove\"](this.settings.classNames.scopeLoading)\n        return this\n    },\n\n    /**\n     * Toogle a tag loading state on/off\n     * @param {Boolean} isLoading\n     */\n    tagLoading( tagElm, isLoading ){\n        if( tagElm )\n            // IE11 doesn't support toggle with second parameter\n            tagElm.classList[isLoading ? \"add\" : \"remove\"](this.settings.classNames.tagLoading)\n        return this\n    },\n\n    /**\n     * Toggles class on the main tagify container (\"scope\")\n     * @param {String} className\n     * @param {Boolean} force\n     */\n    toggleClass( className, force ){\n        if( typeof className == 'string' )\n            this.DOM.scope.classList.toggle(className, force)\n    },\n\n    toggleScopeValidation( validation ){\n        var isValid = validation === true || validation === undefined; // initially it is undefined\n\n        if( !this.settings.required && validation && validation === this.TEXTS.empty)\n            isValid = true\n\n        this.toggleClass(this.settings.classNames.tagInvalid, !isValid)\n        this.DOM.scope.title = isValid ? '' : validation\n    },\n\n    toggleFocusClass( force ){\n        this.toggleClass(this.settings.classNames.focus, !!force)\n    },\n\n    /**\n     * Sets the templates placeholder after initialization\n     * @param {String} str\n     */\n    setPlaceholder(str) {\n        ['data', 'aria'].forEach(p => this.DOM.input.setAttribute(`${p}-placeholder`, str))\n    },\n\n    triggerChangeEvent,\n\n    events,\n\n    fixFirefoxLastTagNoCaret(){\n        return // seems to be fixed in newer version of FF, so retiring below code (for now)\n        // var inputElm = this.DOM.input\n\n        // if( this.isFirefox && inputElm.childNodes.length && inputElm.lastChild.nodeType == 1 ){\n        //     inputElm.appendChild(document.createTextNode(\"\\u200b\"))\n        //     this.setRangeAtStartEnd(true, inputElm)\n        //     return true\n        // }\n    },\n\n    /** https://stackoverflow.com/a/59156872/104380\n     * @param {Boolean} start indicating where to place it (start or end of the node)\n     * @param {Object}  node  DOM node to place the caret at\n     */\n    setRangeAtStartEnd( start, node ){\n        if( !node ) return;\n\n        start = typeof start == 'number' ? start : !!start\n        node = node.lastChild || node;\n        var sel = document.getSelection()\n\n        // do not force caret placement if the current selection (focus) is on another element (not this tagify instance)\n        if( sel.focusNode instanceof Element && !this.DOM.input.contains(sel.focusNode) ) {\n            return true\n        }\n\n        try{\n            if( sel.rangeCount >= 1 ){\n                ['Start', 'End'].forEach(pos =>\n                    sel.getRangeAt(0)[\"set\" + pos](node, start ? start : node.length)\n                )\n            }\n        } catch(err){\n            console.warn(err)\n        }\n    },\n\n    insertAfterTag( tagElm, newNode ){\n        newNode = newNode || this.settings.mixMode.insertAfterTag;\n\n        if( !tagElm || !tagElm.parentNode || !newNode ) return\n\n        newNode = typeof newNode == 'string'\n            ? document.createTextNode(newNode)\n            : newNode\n\n        tagElm.parentNode.insertBefore(newNode, tagElm.nextSibling)\n        return newNode\n    },\n\n    // compares all \"__originalData\" property values with the current \"tagData\" properties\n    // and returns \"true\" if something changed.\n    editTagChangeDetected(tagData) {\n        var originalData = tagData.__originalData;\n\n        for( var prop in originalData )\n            if( !this.dataProps.includes(prop) && tagData[prop] != originalData[prop] )\n                return true\n\n        return false; // not changed\n    },\n\n    // returns the node which has the actual tag's content\n    getTagTextNode(tagElm){\n        return tagElm.querySelector(this.settings.classNames.tagTextSelector)\n    },\n\n    // sets the text of a tag\n    setTagTextNode(tagElm, HTML){\n        this.getTagTextNode(tagElm).innerHTML = escapeHTML(HTML)\n    },\n\n    /**\n     * Enters a tag into \"edit\" mode\n     * @param {Node} tagElm the tag element to edit. if nothing specified, use last last\n     */\n    editTag( tagElm, opts ){\n        tagElm = tagElm || this.getLastTag()\n        opts = opts || {}\n\n        var _s = this.settings,\n            editableElm = this.getTagTextNode(tagElm),\n            tagIdx = this.getNodeIndex(tagElm),\n            tagData = getSetTagData(tagElm),\n            _CB = this.events.callbacks,\n            isValid = true,\n            isSelectMode = _s.mode == 'select'\n\n        // select mode is a bit different as clicking the tagify's content once will get into edit-mode if a value\n        // is already selected, and there cannot be a dropdown already open at this point.\n        !isSelectMode && this.dropdown.hide()\n\n        if( !editableElm ){\n            logger.warn('Cannot find element in Tag template: .', _s.classNames.tagTextSelector);\n            return;\n        }\n\n        if( tagData instanceof Object && \"editable\" in tagData && !tagData.editable )\n            return\n\n        // cache the original data, on the DOM node, before any modification ocurs, for possible revert\n        tagData = getSetTagData(tagElm, {\n            __originalData: extend({}, tagData),\n            __originalHTML: tagElm.cloneNode(true)\n        })\n        // re-set the tagify custom-prop on the clones element (because cloning removed it)\n        getSetTagData(tagData.__originalHTML, tagData.__originalData)\n\n        editableElm.setAttribute('contenteditable', true)\n        tagElm.classList.add( _s.classNames.tagEditing )\n\n        // because \"editTag\" method can be called manually, make sure that \"state.editing\" is set correctly\n        this.events.callbacks.onEditTagFocus.call(this, tagElm)\n\n        editableElm.addEventListener('click'            , _CB.onEditTagClick.bind(this, tagElm))\n        editableElm.addEventListener('blur'             , _CB.onEditTagBlur.bind(this, this.getTagTextNode(tagElm)))\n        editableElm.addEventListener('input'            , _CB.onEditTagInput.bind(this, editableElm))\n        editableElm.addEventListener('paste'            , _CB.onEditTagPaste.bind(this, editableElm))\n        editableElm.addEventListener('keydown'          , e => _CB.onEditTagkeydown.call(this, e, tagElm))\n        editableElm.addEventListener('compositionstart' , _CB.onCompositionStart.bind(this))\n        editableElm.addEventListener('compositionend'   , _CB.onCompositionEnd.bind(this))\n\n        if( !opts.skipValidation )\n            isValid = this.editTagToggleValidity(tagElm)\n\n        editableElm.originalIsValid = isValid\n\n        this.trigger(\"edit:start\", { tag:tagElm, index:tagIdx, data:tagData, isValid })\n\n        editableElm.focus()\n        !isSelectMode && this.setRangeAtStartEnd(false, editableElm) // place the caret at the END of the editable tag text\n\n        _s.dropdown.enabled === 0 && !isSelectMode && this.dropdown.show()\n        this.state.hasFocus = true\n\n        return this\n    },\n\n    /**\n     * If a tag is invalid, for any reason, set its class to \"not allowed\" (see defaults file)\n     * @param {Node} tagElm required\n     * @param {Object} tagData optional\n     * @returns true if valid, a string (reason) if not\n     */\n    editTagToggleValidity( tagElm, tagData ){\n        var tagData = tagData || getSetTagData(tagElm),\n            isValid;\n\n        if( !tagData ){\n            logger.warn(\"tag has no data: \", tagElm, tagData)\n            return;\n        }\n\n        isValid = !(\"__isValid\" in tagData) || tagData.__isValid === true\n\n        if( !isValid ){\n            this.removeTagsFromValue(tagElm)\n        }\n\n        this.update()\n\n        //this.validateTag(tagData);\n\n        tagElm.classList.toggle(this.settings.classNames.tagNotAllowed, !isValid)\n        tagData.__isValid = isValid;\n\n        return tagData.__isValid\n    },\n\n    onEditTagDone(tagElm, tagData){\n        tagElm = tagElm || this.state.editing.scope\n        tagData = tagData || {}\n\n        var eventData = {\n            tag         : tagElm,\n            index       : this.getNodeIndex(tagElm),\n            previousData: getSetTagData(tagElm),\n            data        : tagData\n        }\n\n        var _s = this.settings\n\n        this.trigger(\"edit:beforeUpdate\", eventData, {cloneData:false})\n\n        this.state.editing = false;\n\n        delete tagData.__originalData\n        delete tagData.__originalHTML\n\n        // some scenarrios like in the one in the demos page with textarea that has 2 whitelists, one of the whitelist might be\n        // an array of objects with a property defined the same as the `tagTextProp` setting (if used) but another whitelist\n        // might be simpler - just an array of primitives.\n        function veryfyTagTextProp() {\n            var tagTextProp = tagData[_s.tagTextProp];\n\n            // 'tagTextProp' might also be the number 0 so checking for `undefined` here:\n            if( tagTextProp !== undefined ) {\n                tagTextProp += ''; // cast possible number into a string\n                return !!tagTextProp.trim?.()\n            }\n\n            if( !(_s.tagTextProp in tagData) )\n                return !!tagData.value\n        }\n\n        if( tagElm && veryfyTagTextProp() ){\n            tagElm = this.replaceTag(tagElm, tagData)\n            this.editTagToggleValidity(tagElm, tagData)\n\n            if( _s.a11y.focusableTags )\n                tagElm.focus()\n            else if( _s.mode != 'select' )\n                // place caret after edited tag\n                placeCaretAfterNode(tagElm)\n        }\n\n        else if(tagElm)\n            this.removeTags(tagElm)\n\n        this.trigger(\"edit:updated\", eventData)\n        this.dropdown.hide()\n\n        // check if any of the current tags which might have been marked as \"duplicate\" should be now un-marked\n        if( this.settings.keepInvalidTags )\n            this.reCheckInvalidTags()\n    },\n\n    /**\n     * Replaces an exisitng tag with a new one. Used for updating a tag's data\n     * @param {Object} tagElm  [DOM node to replace]\n     * @param {Object} tagData [data to create new tag from]\n     */\n    replaceTag(tagElm, tagData){\n        if( !tagData || tagData.value === '' || tagData.value === undefined )\n            tagData = tagElm.__tagifyTagData\n\n        // if tag is invalid, make the according changes in the newly created element\n        if( tagData.__isValid && tagData.__isValid != true )\n            extend( tagData, this.getInvalidTagAttrs(tagData, tagData.__isValid) )\n\n        var newTagElm = this.createTagElem(tagData)\n\n        // update DOM\n        tagElm.parentNode.replaceChild(newTagElm, tagElm)\n        this.updateValueByDOMTags()\n        return newTagElm\n    },\n\n    /**\n     * update \"value\" (Array of Objects) by traversing all valid tags\n     */\n    updateValueByDOMTags(){\n        this.value.length = 0;\n\n        var clsNames = this.settings.classNames,\n            tagNotAllowedClassName = clsNames.tagNotAllowed.split(' ')[0],\n            skipNodesWithClassNames = [tagNotAllowedClassName, clsNames.tagHide];\n\n        [].forEach.call(this.getTagElms(), node => {\n            if ([...node.classList].some(cls => skipNodesWithClassNames.includes(cls))) return;\n            this.value.push( getSetTagData(node) )\n        })\n\n        this.update()\n    },\n\n    /**\n     * injects nodes/text at caret position, which is saved on the \"state\" when \"blur\" event gets triggered\n     * @param {Node} injectedNode [the node to inject at the caret position]\n     * @param {Object} selection [optional range Object. must have \"anchorNode\" & \"anchorOffset\"]\n     */\n    injectAtCaret( injectedNode, range ){\n        range = range || this.state.selection?.range\n\n        if(typeof injectedNode === 'string')\n            injectedNode = document.createTextNode(injectedNode)\n\n        if( !range && injectedNode ) {\n            this.appendMixTags(injectedNode)\n            return this;\n        }\n\n        let node = injectAtCaret(injectedNode, range)\n        this.setRangeAtStartEnd(false, node)\n\n        this.updateValueByDOMTags() // updates internal \"this.value\"\n        this.update() // updates original input/textarea\n\n        return this\n    },\n\n    /**\n     * input bridge for accessing & setting\n     * @type {Object}\n     */\n    input : {\n        set( value = '', updateDOM = true ){\n            var _s = this.settings,\n                hideDropdown = _s.dropdown.closeOnSelect\n\n            this.state.inputText = value\n\n            if( updateDOM ) {\n                this.DOM.input.innerHTML = escapeHTML(\"\"+value);\n                value && this.toggleClass(_s.classNames.empty, !this.DOM.input.innerHTML) // remove the \"empty\" (is exists) class only if a value was added\n            }\n\n            if( !value && hideDropdown )\n                this.dropdown.hide.bind(this)\n\n            this.input.autocomplete.suggest.call(this);\n            this.input.validate.call(this);\n\n        },\n\n        raw(){\n            return this.DOM.input.textContent\n        },\n\n        /**\n         * Marks the tagify's input as \"invalid\" if the value did not pass \"validateTag()\"\n         */\n        validate(){\n            var isValid = !this.state.inputText || this.validateTag({value:this.state.inputText}) === true;\n\n            this.DOM.input.classList.toggle(this.settings.classNames.inputInvalid, !isValid)\n\n            return isValid\n        },\n\n        // remove any child DOM elements that aren't of type TEXT (like <br>)\n        normalize( node, options ){\n            var clone = node || this.DOM.input, //.cloneNode(true),\n                v = [];\n\n            // when a text was pasted in FF, the \"this.DOM.input\" element will have <br> but no newline symbols (\\n), and this will\n            // result in tags not being properly created if one wishes to create a separate tag per newline.\n            clone.childNodes.forEach(n => n.nodeType==3 && v.push(n.nodeValue))\n            v = v.join(\"\\n\")\n\n            try{\n                // \"delimiters\" might be of a non-regex value, where this will fail (\"Tags With Properties\" example in demo page):\n                v = v.replace(/(?:\\r\\n|\\r|\\n)/g, this.settings.delimiters.source.charAt(0))\n            }\n            catch(err){}\n\n            v = v.replace(/\\s/g, ' ')  // replace NBSPs with spaces characters\n\n            return options?.trim ? this.trim(v) : v\n        },\n\n        /**\n         * suggest the rest of the input's value (via CSS \"::after\" using \"content:attr(...)\")\n         * @param  {String} s [description]\n         */\n        autocomplete : {\n            suggest( data ){\n                if( !this.settings.autoComplete.enabled ) return;\n\n                data = data || {value:''}\n                if (typeof data !== 'object') data = { value: data };\n\n                var suggestedText = this.dropdown.getMappedValue(data);\n\n                if( typeof suggestedText === 'number' ) return\n\n                var inputText = this.state.inputText.toLowerCase(),\n                    suggestionStart = suggestedText.substr(0, this.state.inputText.length).toLowerCase(),\n                    suggestionTrimmed = suggestedText.substring(this.state.inputText.length);\n\n                if( !suggestedText || !this.state.inputText || suggestionStart != inputText ){\n                    this.DOM.input.removeAttribute(\"data-suggest\");\n                    delete this.state.inputSuggestion\n                }\n                else{\n                    this.DOM.input.setAttribute(\"data-suggest\", suggestionTrimmed);\n                    this.state.inputSuggestion = data\n                }\n            },\n\n            /**\n             * sets the suggested text as the input's value & cleanup the suggestion autocomplete.\n             * @param {String} s [text]\n             */\n            set( s ){\n                var dataSuggest = this.DOM.input.getAttribute('data-suggest'),\n                    suggestion = s || (dataSuggest ? this.state.inputText + dataSuggest : null);\n\n                if( suggestion ){\n                    if( this.settings.mode == 'mix' ){\n                        this.replaceTextWithNode( document.createTextNode(this.state.tag.prefix + suggestion) )\n                    }\n                    else{\n                        this.input.set.call(this, suggestion);\n                        this.setRangeAtStartEnd(false, this.DOM.input)\n                    }\n\n                    this.input.autocomplete.suggest.call(this);\n                    this.dropdown.hide();\n\n                    return true;\n                }\n\n                return false;\n            }\n        }\n    },\n\n    /**\n     * returns the index of the the tagData within the \"this.value\" array collection.\n     * since values should be unique, it is suffice to only search by \"value\" property\n     * @param {Object} tagData\n     */\n    getTagIdx( tagData ){\n        return this.value.findIndex(item => item.__tagId == (tagData||{}).__tagId )\n    },\n\n    getNodeIndex( node ){\n        var index = 0;\n\n        if( node )\n            while( (node = node.previousElementSibling) )\n                index++;\n\n        return index;\n    },\n\n    getTagElms( ...classess ){\n        var classname = '.' + [...this.settings.classNames.tag.split(' '), ...classess].join('.')\n        return [].slice.call(this.DOM.scope.querySelectorAll(classname)) // convert nodeList to Array - https://stackoverflow.com/a/3199627/104380\n    },\n\n    /**\n     * gets the last non-readonly, not-in-the-proccess-of-removal tag\n     */\n    getLastTag(){\n        var _sc = this.settings.classNames,\n            tagNodes = this.DOM.scope.querySelectorAll(`${_sc.tagSelector}:not(.${_sc.tagHide}):not([readonly])`);\n        return tagNodes[tagNodes.length - 1];\n    },\n\n    /**\n     * Searches if any tag with a certain value already exis\n     * @param  {String/Object} value [text value / tag data object]\n     * @param  {Boolean} caseSensitive\n     * @return {Number}\n     */\n    isTagDuplicate( value, caseSensitive, tagId ){\n        var dupsCount = 0;\n\n        for( let item of this.value ) {\n            let isSameStr = sameStr( this.trim(\"\"+value), item.value, caseSensitive );\n            if( isSameStr && tagId != item.__tagId )\n                dupsCount++;\n        }\n\n        return dupsCount\n    },\n\n    getTagIndexByValue( value ){\n        var indices = [],\n            isCaseSensitive = this.settings.dropdown.caseSensitive;\n\n        this.getTagElms().forEach((tagElm, i) => {\n            if(  tagElm.__tagifyTagData && sameStr( this.trim(tagElm.__tagifyTagData.value), value, isCaseSensitive )  )\n                indices.push(i)\n        })\n\n        return indices;\n    },\n\n    getTagElmByValue( value ){\n        var tagIdx = this.getTagIndexByValue(value)[0]\n        return this.getTagElms()[tagIdx]\n    },\n\n    /**\n     * Temporarily marks a tag element (by value or Node argument)\n     * @param  {Object} tagElm [a specific \"tag\" element to compare to the other tag elements siblings]\n     */\n    flashTag( tagElm ){\n        if( tagElm ){\n            tagElm.classList.add(this.settings.classNames.tagFlash)\n            setTimeout(() => { tagElm.classList.remove(this.settings.classNames.tagFlash) }, 100)\n        }\n    },\n\n    /**\n     * checks if text is in the blacklist\n     */\n    isTagBlacklisted( v ){\n        v = this.trim(v.toLowerCase());\n        return this.settings.blacklist.filter(x => (\"\"+x).toLowerCase() == v).length;\n    },\n\n    /**\n     * checks if text is in the whitelist\n     */\n    isTagWhitelisted( v ){\n        return !!this.getWhitelistItem(v)\n        /*\n        return this.settings.whitelist.some(item =>\n            typeof v == 'string'\n                ? sameStr(this.trim(v), (item.value || item))\n                : sameStr(JSON.stringify(item), JSON.stringify(v))\n        )\n        */\n    },\n\n    /**\n     * Returns the first whitelist item matched, by value (if match found)\n     * @param {String} value [text to match by]\n     */\n    getWhitelistItem( value, prop, whitelist ){\n        var result,\n            prop = prop || 'value',\n            _s = this.settings,\n            whitelist = whitelist || _s.whitelist;\n\n        whitelist.some(_wi => {\n            // whitelist item value. Can be either a String, Number or an Object (with a `value` property)\n            var _wiv = typeof _wi == 'object' ? (_wi[prop] || _wi.value) : _wi,\n                isSameStr = sameStr(_wiv, value, _s.dropdown.caseSensitive, _s.trim)\n\n            if( isSameStr ){\n                result = typeof _wi == 'object' ? _wi : {value:_wi}\n                return true\n            }\n        })\n\n        // first iterate the whitelist, try find matches by \"value\" and if that fails\n        // and a \"tagTextProp\" is set to be other than \"value\", try that also\n        if( !result && prop == 'value' && _s.tagTextProp != 'value' ){\n            // if found, adds the first which matches\n            result = this.getWhitelistItem(value, _s.tagTextProp, whitelist)\n        }\n\n        return result\n    },\n\n    /**\n     * validate a tag object BEFORE the actual tag will be created & appeneded\n     * @param  {String} s\n     * @param  {String} uid      [unique ID, to not inclue own tag when cheking for duplicates]\n     * @return {Boolean/String}  [\"true\" if validation has passed, String for a fail]\n     */\n    validateTag( tagData ){\n        var _s = this.settings,\n            // when validating a tag in edit-mode, need to take \"tagTextProp\" into consideration\n            prop = \"value\" in tagData ? \"value\" : _s.tagTextProp,\n            v = this.trim(tagData[prop] + \"\");\n\n        // check for definitive empty value\n        if( !(tagData[prop]+\"\").trim() )\n            return this.TEXTS.empty;\n\n        // check if pattern should be used and if so, use it to test the value\n        if( _s.mode != 'mix' && _s.pattern && _s.pattern instanceof RegExp && !(_s.pattern.test(v)) )\n            return this.TEXTS.pattern;\n\n        // check for duplicates\n        if( !_s.duplicates && this.isTagDuplicate(v, _s.dropdown.caseSensitive, tagData.__tagId) )\n            return this.TEXTS.duplicate;\n\n        if( this.isTagBlacklisted(v) || (_s.enforceWhitelist && !this.isTagWhitelisted(v)) )\n            return this.TEXTS.notAllowed;\n\n        if( _s.validate )\n            return _s.validate(tagData)\n\n        return true\n    },\n\n    getInvalidTagAttrs(tagData, validation){\n        return {\n            \"aria-invalid\" : true,\n            \"class\": `${tagData.class || ''} ${this.settings.classNames.tagNotAllowed}`.trim(),\n            \"title\": validation\n        }\n    },\n\n    hasMaxTags(){\n        return this.value.length >= this.settings.maxTags\n            ? this.TEXTS.exceed\n            : false\n    },\n\n    setReadonly( toggle, attrribute ){\n        var _s = this.settings\n\n        this.DOM.scope.contains(document.activeElement) && document.activeElement.blur() // exit possible edit-mode\n        _s[attrribute || 'readonly'] = toggle\n        this.DOM.scope[(toggle ? 'set' : 'remove') + 'Attribute'](attrribute || 'readonly', true)\n\n        this.settings.userInput = true;\n        this.setContentEditable(!toggle)\n    },\n\n    setContentEditable(state){\n        this.DOM.input.contentEditable = state\n        this.DOM.input.tabIndex = !!state ? 0 : -1;\n    },\n\n    setDisabled( isDisabled ){\n        this.setReadonly(isDisabled, 'disabled')\n    },\n\n    /**\n     * pre-proccess the tagsItems, which can be a complex tagsItems like an Array of Objects or a string comprised of multiple words\n     * so each item should be iterated on and a tag created for.\n     * @return {Array} [Array of Objects]\n     */\n    normalizeTags( tagsItems ){\n        var {whitelist, delimiters, mode, tagTextProp} = this.settings,\n            whitelistMatches = [],\n            whitelistWithProps = whitelist ? whitelist[0] instanceof Object : false,\n            // checks if this is a \"collection\", meanning an Array of Objects\n            isArray = Array.isArray(tagsItems),\n            isCollection = isArray && tagsItems[0].value,\n            mapStringToCollection = s => (s+\"\").split(delimiters).reduce((acc, v) => {\n                const trimmed = this.trim(v)\n                trimmed && acc.push({ [tagTextProp]:trimmed, value:trimmed })\n                return acc\n            }, [])\n\n        if( typeof tagsItems == 'number' )\n            tagsItems = tagsItems.toString()\n\n        // if the argument is a \"simple\" String, ex: \"aaa, bbb, ccc\"\n        if( typeof tagsItems == 'string' ){\n            if( !tagsItems.trim() ) return [];\n\n            // go over each tag and add it (if there were multiple ones)\n            tagsItems = mapStringToCollection(tagsItems)\n        }\n\n        // if is an Array of Strings, convert to an Array of Objects\n        else if( isArray ){\n            // flatten the 2D array\n            tagsItems = tagsItems.reduce((acc, item) => {\n                if( isObject(item) ) {\n                    var itemCopy = extend({}, item)\n\n                    // if 'tagTextProp' property does not exist in the item, use `value` instead\n                    if(!(tagTextProp in itemCopy))\n                        tagTextProp = 'value'\n\n                    itemCopy[tagTextProp] = this.trim(itemCopy[tagTextProp])\n\n                    // discard empty tags but allow `0` as a valid value\n                    if( itemCopy[tagTextProp] || itemCopy[tagTextProp] === 0 )\n                        acc.push(itemCopy) // mapStringToCollection(item.value).map(newItem => ({...item,...newItem}))\n                }\n\n                else if(item != null && item !== '' && item !== undefined) {\n                    acc.push( ...mapStringToCollection(item) )\n                }\n\n                return acc\n            }, [])\n        }\n\n        // search if the tag exists in the whitelist as an Object (has props),\n        // to be able to use its properties.\n        // skip matching collections with whitelist items as they are considered \"whole\"\n        if( whitelistWithProps && !isCollection ){\n            tagsItems.forEach(item => {\n                var whitelistMatchesValues = whitelistMatches.map(a=>a.value)\n\n                // if suggestions are shown, they are already filtered, so it's easier to use them,\n                // because the whitelist might also include items which have already been added\n                var filteredList = this.dropdown.filterListItems.call(this, item[tagTextProp], { exact:true })\n\n                if( !this.settings.duplicates )\n                    // also filter out items which have already been matched in previous iterations\n                    filteredList = filteredList.filter(filteredItem => !whitelistMatchesValues.includes(filteredItem.value))\n\n                // get the best match out of list of possible matches.\n                // if there was a single item in the filtered list, use that one\n                var matchObj = filteredList.length > 1\n                    ? this.getWhitelistItem(item[tagTextProp], tagTextProp, filteredList)\n                    : filteredList[0]\n\n                if( matchObj && matchObj instanceof Object ){\n                    whitelistMatches.push( matchObj ) // set the Array (with the found Object) as the new value\n                }\n                else if( mode != 'mix' ){\n                    if( item.value == undefined )\n                        item.value = item[tagTextProp]\n                    whitelistMatches.push(item)\n                }\n            })\n\n            if( whitelistMatches.length )\n                tagsItems = whitelistMatches\n        }\n\n        return tagsItems;\n    },\n\n    /**\n     * Parse the initial value of a textarea (or input) element and generate mixed text w/ tags\n     * https://stackoverflow.com/a/57598892/104380\n     * @param {String} s\n     */\n    parseMixTags( s ){\n        var {mixTagsInterpolator, duplicates, transformTag, enforceWhitelist, maxTags, tagTextProp} = this.settings,\n            tagsDataSet = [];\n\n        s = s.split(mixTagsInterpolator[0]).map((s1, i) => {\n            var s2 = s1.split(mixTagsInterpolator[1]),\n                preInterpolated = s2[0],\n                maxTagsReached = tagsDataSet.length == maxTags,\n                textProp,\n                tagData,\n                tagElm;\n\n            try{\n                // skip numbers and go straight to the \"catch\" statement\n                if( preInterpolated == +preInterpolated )\n                    throw Error\n                tagData = JSON.parse(preInterpolated)\n            } catch(err){\n                tagData = this.normalizeTags(preInterpolated)[0] || {value:preInterpolated}\n            }\n\n            transformTag.call(this, tagData)\n\n            if( !maxTagsReached   &&\n                s2.length > 1   &&\n                (!enforceWhitelist || this.isTagWhitelisted(tagData.value))   &&\n                !(!duplicates && this.isTagDuplicate(tagData.value)) ){\n\n                // in case \"tagTextProp\" setting is set to other than \"value\" and this tag does not have this prop\n                textProp = tagData[tagTextProp] ? tagTextProp : 'value'\n                tagData[textProp] = this.trim(tagData[textProp])\n\n                tagElm = this.createTagElem(tagData)\n                tagsDataSet.push( tagData )\n                tagElm.classList.add(this.settings.classNames.tagNoAnimation)\n\n                s2[0] = tagElm.outerHTML //+ \"&#8288;\"  // put a zero-space at the end so the caret won't jump back to the start (when the last input's child element is a tag)\n                this.value.push(tagData)\n            }\n            else if(s1)\n                return i ? mixTagsInterpolator[0] + s1 : s1\n\n            return s2.join('')\n        }).join('')\n\n        this.DOM.input.innerHTML = s\n        this.DOM.input.appendChild(document.createTextNode(''))\n        this.DOM.input.normalize()\n\n        var tagNodes = this.getTagElms()\n\n        tagNodes.forEach((elm, idx) => getSetTagData(elm,  tagsDataSet[idx]))\n        this.update({withoutChangeEvent:true})\n\n        fixCaretBetweenTags(tagNodes, this.state.hasFocus)\n        return s\n    },\n\n    /**\n     * For mixed-mode: replaces a text starting with a prefix with a wrapper element (tag or something)\n     * First there *has* to be a \"this.state.tag\" which is a string that was just typed and is staring with a prefix\n     */\n    replaceTextWithNode( newWrapperNode, strToReplace ){\n        if( !this.state.tag && !strToReplace ) return;\n\n        strToReplace = strToReplace || this.state.tag.prefix + this.state.tag.value;\n        var idx, nodeToReplace,\n            selection = this.state.selection || window.getSelection(),\n            nodeAtCaret = selection.anchorNode,\n            firstSplitOffset = this.state.tag.delimiters ? this.state.tag.delimiters.length : 0;\n\n        // STEP 1: ex. replace #ba with the tag \"bart\" where \"|\" is where the caret is:\n        // CURRENT STATE: \"foo #ba #ba| #ba\"\n\n        // split the text node at the index of the caret\n        nodeAtCaret.splitText(selection.anchorOffset - firstSplitOffset)\n\n        // node 0: \"foo #ba #ba|\"\n        // node 1: \" #ba\"\n\n        // get index of LAST occurence of \"#ba\"\n        idx = nodeAtCaret.nodeValue.lastIndexOf(strToReplace)\n\n        if( idx == -1 ) return true;\n\n        nodeToReplace = nodeAtCaret.splitText(idx)\n\n        // node 0: \"foo #ba \"\n        // node 1: \"#ba\"    <- nodeToReplace\n\n        newWrapperNode && nodeAtCaret.parentNode.replaceChild(newWrapperNode, nodeToReplace)\n\n        // must NOT normalize contenteditable or it will cause unwanted issues:\n        // https://monosnap.com/file/ZDVmRvq5upYkidiFedvrwzSswegWk7\n        // nodeAtCaret.parentNode.normalize()\n\n        return true;\n    },\n\n    /**\n     * Validate a tag's data and create a new tag node\n     * @param {*} tagData\n     * @param {*} options\n     * @returns Object\n     */\n    prepareNewTagNode(tagData, options) {\n        options = options || {}\n\n        var tagElm,\n            _s = this.settings,\n            aggregatedInvalidInput = [],\n            tagElmParams = {},\n            originalData = Object.assign({}, tagData, {value:tagData.value+\"\"});\n\n        // shallow-clone tagData so later modifications will not apply to the source\n        tagData = Object.assign({}, originalData)\n        _s.transformTag.call(this, tagData)\n\n        tagData.__isValid = this.hasMaxTags() || this.validateTag(tagData)\n\n        if( tagData.__isValid !== true ){\n            if( options.skipInvalid )\n                return\n\n            // originalData is kept because it might be that this tag is invalid because it is a duplicate of another,\n            // and if that other tags is edited/deleted, this one should be re-validated and if is no more a duplicate - restored\n            extend(tagElmParams, this.getInvalidTagAttrs(tagData, tagData.__isValid), {__preInvalidData:originalData})\n\n            if( tagData.__isValid == this.TEXTS.duplicate )\n                // mark, for a brief moment, the tag (this this one) which THIS CURRENT tag is a duplcate of\n                this.flashTag( this.getTagElmByValue(tagData.value) )\n\n            if( !_s.createInvalidTags ){\n                aggregatedInvalidInput.push(tagData.value)\n                return\n            }\n        }\n\n        if( 'readonly' in tagData ){\n            if( tagData.readonly )\n                tagElmParams[\"aria-readonly\"] = true\n            // if \"readonly\" is \"false\", remove it from the tagData so it won't be added as an attribute in the template\n            else\n                delete tagData.readonly\n        }\n\n        // Create tag HTML element\n        tagElm = this.createTagElem(tagData, tagElmParams)\n\n        return {tagElm, tagData, aggregatedInvalidInput}\n    },\n\n    /**\n     * Logic to happen once a tag has just been injected into the DOM\n     * @param {Node} tagElm\n     * @param {Object} tagData\n     */\n    postProcessNewTagNode(tagElm, tagData) {\n        var _s = this.settings,\n            isValid = tagData.__isValid;\n\n        if( isValid && isValid === true ){\n            // update state\n            this.value.push(tagData)\n        }\n        else{\n            this.trigger('invalid', {data:tagData, index:this.value.length, tag:tagElm, message:isValid})\n            if( !_s.keepInvalidTags )\n                // remove invalid tags (if \"keepInvalidTags\" is set to \"false\")\n                setTimeout(() => this.removeTags(tagElm, true), 1000)\n        }\n\n        this.dropdown.position() // reposition the dropdown because the just-added tag might cause a new-line\n    },\n\n    /**\n     * For selecting a single option (not used for multiple tags, but for \"mode:select\" only)\n     * @param {Object} tagElm   Tag DOM node\n     * @param {Object} tagData  Tag data\n     */\n    selectTag( tagElm, tagData ){\n        var _s = this.settings\n\n        if( _s.enforceWhitelist && !this.isTagWhitelisted(tagData.value) )\n            return\n\n        // this.input.set.call(this, tagData[_s.tagTextProp] || tagData.value, true)\n\n        // place the caret at the end of the input, only if a dropdown option was selected (and not by manually typing another value and clicking \"TAB\")\n        if( this.state.actions.selectOption )\n            setTimeout(() => this.setRangeAtStartEnd(false, this.DOM.input))\n\n        var lastTagElm = this.getLastTag()\n\n        if( lastTagElm )\n            this.replaceTag(lastTagElm, tagData)\n        else\n            this.appendTag(tagElm)\n\n        // if( _s.enforceWhitelist )\n        //     this.setContentEditable(false);\n\n        this.value[0] = tagData\n        this.update()\n        this.trigger('add', { tag:tagElm, data:tagData })\n\n        return [tagElm]\n    },\n\n    /**\n     * add an empty \"tag\" element in an editable state\n     */\n    addEmptyTag( initialData ){\n        var tagData = extend({ value:\"\" }, initialData || {}),\n            tagElm = this.createTagElem(tagData)\n\n        getSetTagData(tagElm, tagData)\n\n        // add the tag to the component's DOM\n        this.appendTag(tagElm)\n        this.editTag(tagElm, {skipValidation:true})\n        this.toggleFocusClass(true)\n    },\n\n    /**\n     * add a \"tag\" element to the \"tags\" component\n     * @param {String/Array} tagsItems   [A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings]\n     * @param {Boolean}      clearInput  [flag if the input's value should be cleared after adding tags]\n     * @param {Boolean}      skipInvalid [do not add, mark & remove invalid tags]\n     * @return {Array} Array of DOM elements (tags)\n     */\n    addTags( tagsItems, clearInput, skipInvalid ){\n        var tagElems = [],\n            _s = this.settings,\n            aggregatedInvalidInput = [],\n            frag = document.createDocumentFragment(),\n            addedTags = []; // all tags, also invalid. this is used for firing the `add` event\n\n        if( !tagsItems || tagsItems.length == 0 ){\n            return tagElems\n        }\n\n        // converts Array/String/Object to an Array of Objects\n        tagsItems = this.normalizeTags(tagsItems)\n\n        switch( _s.mode ){\n            case 'mix': return this.addMixTags(tagsItems)\n            case 'select': {\n                clearInput = false\n                this.removeAllTags()\n            }\n        }\n\n        this.DOM.input.removeAttribute('style')\n\n        tagsItems.forEach(tagData => {\n            const newTagNode = this.prepareNewTagNode(tagData, {skipInvalid: skipInvalid || _s.skipInvalid});\n\n            if( !newTagNode) return;\n\n            const tagElm = newTagNode.tagElm;\n\n            tagData = newTagNode.tagData\n            aggregatedInvalidInput = newTagNode.aggregatedInvalidInput\n\n            tagElems.push(tagElm)\n\n            // mode-select overrides\n            if( _s.mode == 'select' ){\n                return this.selectTag(tagElm, tagData)\n            }\n\n            // add the tag to the component's DOM\n            // this.appendTag(tagElm)\n            frag.appendChild(tagElm)\n            this.postProcessNewTagNode(tagElm, tagData)\n            addedTags.push({tagElm, tagData})\n        })\n\n        this.appendTag(frag)\n\n        addedTags.forEach(({tagElm, tagData}) =>\n            this.trigger('add', {tag:tagElm, index:this.getTagIdx(tagData), data:tagData})\n        )\n\n        this.update()\n\n\n        if( tagsItems.length && clearInput ){\n            this.input.set.call(this, _s.createInvalidTags ? '' : aggregatedInvalidInput.join(_s._delimiters))\n            this.setRangeAtStartEnd(false, this.DOM.input)\n        }\n\n        // refilter hydrate the list\n        this.dropdown.refilter()\n        return tagElems\n    },\n\n    /**\n     * Adds a mix-content tag\n     * @param {String/Array} tagData    A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings\n     */\n    addMixTags( tagsData ){\n        tagsData = this.normalizeTags(tagsData);\n\n        // flow for creating custom tags which aren't a part of the whitelist\n        if( tagsData[0].prefix || this.state.tag ){\n            return this.prefixedTextToTag(tagsData[0])\n        }\n\n        var frag = document.createDocumentFragment()\n\n        tagsData.forEach(tagData => {\n            const newTagNode = this.prepareNewTagNode(tagData)\n            frag.appendChild(newTagNode.tagElm)\n            this.insertAfterTag(newTagNode.tagElm)\n            this.postProcessNewTagNode(newTagNode.tagElm, newTagNode.tagData)\n        })\n\n        this.appendMixTags(frag)\n\n        return frag.children\n    },\n\n    appendMixTags( node ) {\n        var selection = !!this.state.selection;\n\n        // if \"selection\" exists, assumes intention of inecting the new tag at the last\n        // saved location of the caret inside \"this.DOM.input\"\n        if( selection ){\n            this.injectAtCaret(node)\n        }\n        // else, create a range and inject the new tag as the last child of \"this.DOM.input\"\n        else{\n            this.DOM.input.focus()\n            selection = this.setStateSelection()\n            selection.range.setStart(this.DOM.input, selection.range.endOffset)\n            selection.range.setEnd(this.DOM.input, selection.range.endOffset)\n            this.DOM.input.appendChild(node)\n\n            this.updateValueByDOMTags() // updates internal \"this.value\"\n            this.update() // updates original input/textarea\n        }\n    },\n\n    /**\n     * Adds a tag which was activly typed by the user\n     * @param {String/Array} tagData   [A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings]\n     */\n    prefixedTextToTag( tagData ){\n        var _s = this.settings,\n            tagElm,\n            newTag,\n            createdFromDelimiters = this.state.tag?.delimiters;\n\n        tagData.prefix = tagData.prefix || this.state.tag ? this.state.tag.prefix : (_s.pattern.source||_s.pattern)[0];\n\n        newTag = this.prepareNewTagNode(tagData)\n        tagElm = newTag.tagElm\n\n        // tries to replace a taged textNode with a tagElm, and if not able,\n        // insert the new tag to the END if \"addTags\" was called from outside\n        if( !this.replaceTextWithNode(tagElm) ){\n            this.DOM.input.appendChild(tagElm)\n        }\n\n        setTimeout(()=> tagElm.classList.add(this.settings.classNames.tagNoAnimation), 300)\n\n        this.update()\n\n        if( !createdFromDelimiters ) {\n            var elm = this.insertAfterTag(tagElm) || tagElm;\n            // a timeout is needed when selecting a tag from the suggestions via mouse.\n            // Without it, it seems the caret is placed right after the tag and not after the\n            // node which was inserted after the tag (whitespace by default)\n            setTimeout(placeCaretAfterNode, 0, elm);\n        }\n\n        this.state.tag = null\n\n        this.postProcessNewTagNode(tagElm, newTag.tagData)\n\n        return tagElm\n    },\n\n    /**\n     * appened (validated) tag to the component's DOM scope\n     */\n    appendTag(tagElm){\n        var DOM = this.DOM,\n            insertBeforeNode = DOM.input;\n\n        //if( insertBeforeNode === DOM.input )\n            DOM.scope.insertBefore(tagElm, insertBeforeNode)\n        //else\n        //    DOM.scope.appendChild(tagElm)\n    },\n\n    /**\n     * creates a DOM tag element and injects it into the component (this.DOM.scope)\n     * @param  {Object}  tagData [text value & properties for the created tag]\n     * @param  {Object}  extraData [properties which are for the HTML template only]\n     * @return {Object} [DOM element]\n     */\n    createTagElem( tagData, extraData ){\n        tagData.__tagId = getUID()\n\n        var tagElm,\n            templateData = extend({}, tagData, { value:escapeHTML(tagData.value+\"\"), ...extraData });\n\n        // if( this.settings.readonly )\n        //     tagData.readonly = true\n\n        tagElm = this.parseTemplate('tag', [templateData, this])\n\n        // crucial for proper caret placement when deleting content. if textNodes are allowed as children of a tag element,\n        // a browser bug casues the caret to be misplaced inside the tag element (especially affects \"readonly\" tags)\n        removeTextChildNodes(tagElm)\n        // while( tagElm.lastChild.nodeType == 3 )\n        //     tagElm.lastChild.parentNode.removeChild(tagElm.lastChild)\n\n        getSetTagData(tagElm, tagData)\n        return tagElm\n    },\n\n    /**\n     * re-check all invalid tags.\n     * called after a tag was edited or removed\n     */\n    reCheckInvalidTags(){\n        var _s = this.settings\n\n        this.getTagElms(_s.classNames.tagNotAllowed).forEach((tagElm, i) => {\n            var tagData = getSetTagData(tagElm),\n                hasMaxTags = this.hasMaxTags(),\n                tagValidation = this.validateTag(tagData),\n                isValid = tagValidation === true && !hasMaxTags;\n\n            if( _s.mode == 'select' )\n                this.toggleScopeValidation(tagValidation)\n\n            // if the tag has become valid\n            if( isValid ){\n                tagData = tagData.__preInvalidData\n                    ? tagData.__preInvalidData\n                    : { value:tagData.value }\n\n                return this.replaceTag(tagElm, tagData)\n            }\n\n            // if the tag is still invaild, set its title as such (reson of invalid might have changed)\n            tagElm.title = hasMaxTags || tagValidation\n        })\n    },\n\n    /**\n     * Removes a tag\n     * @param  {Array|Node|String}  tagElms         [DOM element(s) or a String value. if undefined or null, remove last added tag]\n     * @param  {Boolean}            silent          [A flag, which when turned on, does not remove any value and does not update the original input value but simply removes the tag from tagify]\n     * @param  {Number}             tranDuration    [Transition duration in MS]\n     * TODO: Allow multiple tags to be removed at-once\n     */\n    removeTags( tagElms, silent, tranDuration ){\n        var tagsToRemove,\n            _s = this.settings;\n\n        tagElms = tagElms && tagElms instanceof HTMLElement\n            ? [tagElms]\n            : tagElms instanceof Array\n                ? tagElms\n                : tagElms\n                    ? [tagElms]\n                    : [this.getLastTag()].filter(n => n)   // must filter because \"this.getLastTag()\" might be `undefined` if there are not tags\n\n        // normalize tagElms array values:\n        // 1. removing invalid items\n        // 2, if an item is String try to get the matching Tag HTML node\n        // 3. get the tag data\n        // 4. return a collection of Objects\n        tagsToRemove = tagElms.reduce((elms, tagElm) => {\n            if( tagElm && typeof tagElm == 'string')\n                tagElm = this.getTagElmByValue(tagElm)\n\n            var tagData = getSetTagData(tagElm);\n\n            if( tagElm && tagData && !tagData.readonly ) // make sure it's a tag and not some other node\n                // because the DOM node might be removed by async animation, the state will be updated while\n                // the node might still be in the DOM, so the \"update\" method should know which nodes to ignore\n                elms.push({\n                    node: tagElm,\n                    idx: this.getTagIdx(tagData), // this.getNodeIndex(tagElm); // this.getTagIndexByValue(tagElm.textContent)\n                    data: getSetTagData(tagElm, {'__removed':true})\n                })\n\n            return elms\n        }, [])\n\n        tranDuration = typeof tranDuration == \"number\" ? tranDuration : this.CSSVars.tagHideTransition\n\n        if( _s.mode == 'select' ){\n            tranDuration = 0;\n            this.input.set.call(this)\n        }\n\n        // if only a single tag is to be removed.\n        // skip \"select\" mode because invalid tags are actually set to `this.value`\n        if( tagsToRemove.length == 1 && _s.mode != 'select' ){\n            if( tagsToRemove[0].node.classList.contains(_s.classNames.tagNotAllowed) )\n                silent = true\n        }\n\n        if( !tagsToRemove.length )\n            return;\n\n        return _s.hooks.beforeRemoveTag(tagsToRemove, {tagify:this})\n            .then(() => {\n                function removeNode( tag ){\n                    if( !tag.node.parentNode ) return\n\n                    tag.node.parentNode.removeChild(tag.node)\n\n                    if( !silent ){\n                        // this.removeValueById(tagData.__uid)\n                        this.trigger('remove', { tag:tag.node, index:tag.idx, data:tag.data })\n                        this.dropdown.refilter()\n                        this.dropdown.position()\n                        this.DOM.input.normalize() // best-practice when in mix-mode (safe to do always anyways)\n\n                        // check if any of the current tags which might have been marked as \"duplicate\" should be un-marked\n                        if( _s.keepInvalidTags )\n                            this.reCheckInvalidTags()\n\n                        // below code is unfinished. it should iterate all currently invalid edited tags, which their edits have not\n                        // changed the value yet, and should re-trigger the check, but since nothing has changed, it does not work...\n                        // this.getTagElms(_s.classNames.tagEditing).forEach( this.events.callbacks.onEditTagBlur.bind )\n                    }\n                    else if( _s.keepInvalidTags )\n                        this.trigger('remove', { tag:tag.node, index:tag.idx })\n                }\n\n                function animation( tag ){\n                    tag.node.style.width = parseFloat(window.getComputedStyle(tag.node).width) + 'px'\n                    document.body.clientTop // force repaint for the width to take affect before the \"hide\" class below\n                    tag.node.classList.add(_s.classNames.tagHide)\n\n                    // manual timeout (hack, since transitionend cannot be used because of hover)\n                    setTimeout(removeNode.bind(this), tranDuration, tag)\n                }\n\n                if( tranDuration && tranDuration > 10 && tagsToRemove.length == 1 )\n                    animation.call(this, tagsToRemove[0])\n                else\n                    tagsToRemove.forEach(removeNode.bind(this))\n\n                // update state regardless of animation\n                if( !silent ){\n                    this.removeTagsFromValue(tagsToRemove.map(tag => tag.node))\n                    this.update() // update the original input with the current value\n\n                    if( _s.mode == 'select' && _s.userInput )\n                        this.setContentEditable(true);\n                }\n            })\n            .catch(reason => {})\n    },\n\n    removeTagsFromDOM(){\n        this.getTagElms().forEach(node => node.remove())\n    },\n\n    /**\n     * @param {Array/Node} tags to be removed from the this.value array\n     */\n    removeTagsFromValue( tags ){\n        tags = Array.isArray(tags) ? tags : [tags];\n\n        tags.forEach(tag => {\n            var tagData = getSetTagData(tag),\n                tagIdx = this.getTagIdx(tagData)\n\n            //  delete tagData.__removed\n\n            if( tagIdx > -1 )\n                this.value.splice(tagIdx, 1)\n        })\n    },\n\n    removeAllTags( opts ){\n        opts = opts || {}\n        this.value = []\n\n        if( this.settings.mode == 'mix' )\n            this.DOM.input.innerHTML = ''\n        else\n            this.removeTagsFromDOM()\n\n        this.dropdown.refilter()\n        this.dropdown.position()\n\n        if( this.state.dropdown.visible )\n            setTimeout(() => {\n                this.DOM.input.focus()\n            })\n\n        if( this.settings.mode == 'select' ){\n            this.input.set.call(this)\n            this.settings.userInput && this.setContentEditable(true)\n        }\n\n        // technically for now only \"withoutChangeEvent\" exists in the opts.\n        // if more properties will be added later, only pass what's needed to \"update\"\n        this.update(opts)\n    },\n\n    postUpdate(){\n        this.state.blockChangeEvent = false\n\n        var _s = this.settings,\n            classNames = _s.classNames,\n            hasValue = _s.mode == 'mix'\n                ? _s.mixMode.integrated\n                    ? this.DOM.input.textContent\n                    : this.DOM.originalInput.value.trim()\n                : this.value.length + this.input.raw.call(this).length;\n\n        this.toggleClass(classNames.hasMaxTags, this.value.length >= _s.maxTags)\n        this.toggleClass(classNames.hasNoTags, !this.value.length)\n        this.toggleClass(classNames.empty, !hasValue)\n\n        // specifically the \"select mode\" might have the \"invalid\" classname set when the field is changed, so it must be toggled on add/remove/edit\n        if( _s.mode == 'select' ){\n            this.toggleScopeValidation(this.value?.[0]?.__isValid)\n        }\n    },\n\n    setOriginalInputValue( v ){\n        var inputElm = this.DOM.originalInput;\n\n        if( !this.settings.mixMode.integrated ){\n            inputElm.value = v\n            inputElm.tagifyValue = inputElm.value // must set to \"inputElm.value\" and not again to \"inputValue\" because for some reason the browser changes the string afterwards a bit.\n            this.setPersistedData(v, 'value')\n        }\n    },\n\n    /**\n     * update the origianl (hidden) input field's value\n     * see - https://stackoverflow.com/q/50957841/104380\n     */\n    update( args ){\n        const UPDATE_DELAY = 100\n        clearTimeout(this.debouncedUpdateTimeout)\n        this.debouncedUpdateTimeout = setTimeout(reallyUpdate.bind(this), UPDATE_DELAY)\n        this.events.bindOriginaInputListener.call(this, UPDATE_DELAY)\n\n        function reallyUpdate() {\n            var inputValue = this.getInputValue();\n\n            this.setOriginalInputValue(inputValue)\n\n            if( (!this.settings.onChangeAfterBlur || !(args||{}).withoutChangeEvent) && !this.state.blockChangeEvent )\n                this.triggerChangeEvent()\n\n            this.postUpdate()\n        }\n    },\n\n    getInputValue(){\n        var value = this.getCleanValue();\n\n        return this.settings.mode == 'mix'\n            ? this.getMixedTagsAsString(value)\n            : value.length\n                ? this.settings.originalInputValueFormat\n                    ? this.settings.originalInputValueFormat(value)\n                    : JSON.stringify(value)\n                : \"\"\n    },\n\n    /**\n     * removes properties from `this.value` which are only used internally\n     */\n    getCleanValue(v){\n        return removeCollectionProp(v || this.value, this.dataProps);\n    },\n\n    getMixedTagsAsString(){\n        var result = \"\",\n            that = this,\n            _s = this.settings,\n            originalInputValueFormat = _s.originalInputValueFormat || JSON.stringify,\n            _interpolator = _s.mixTagsInterpolator;\n\n        function iterateChildren(rootNode){\n            rootNode.childNodes.forEach((node) => {\n                if( node.nodeType == 1 ){\n                    const tagData = getSetTagData(node);\n\n                    if( node.tagName == 'BR'  ){\n                        result += \"\\r\\n\";\n                    }\n\n                    if( tagData && isNodeTag.call(that, node) ){\n                        if( tagData.__removed )\n                            return;\n                        else\n                            result += _interpolator[0] + originalInputValueFormat( omit(tagData, that.dataProps) ) + _interpolator[1]\n                    }\n                    else if( node.getAttribute('style') || ['B', 'I', 'U'].includes(node.tagName)  )\n                        result += node.textContent;\n\n                    else if( node.tagName == 'DIV' || node.tagName == 'P' ){\n                        result += \"\\r\\n\";\n                        //  if( !node.children.length && node.textContent )\n                        //  result += node.textContent;\n                        iterateChildren(node)\n                    }\n                }\n                else\n                    result += node.textContent;\n            })\n        }\n\n        iterateChildren(this.DOM.input)\n\n        return result;\n    }\n}\n\n// legacy support for changed methods names\nTagify.prototype.removeTag = Tagify.prototype.removeTags\n\nexport default Tagify\n", "import { extend, logger } from './helpers'\r\n\r\nexport default function EventDispatcher( instance ){\r\n    // Create a DOM EventTarget object\r\n    var target = document.createTextNode(''),\r\n        // keep track of all binded events & their callbacks to be able to completely remove all listeners of a speicific type\r\n        callbacksPerType = {}\r\n\r\n    function addRemove(op, events, cb){\r\n        if( cb )\r\n            events.split(/\\s+/g).forEach(ev => target[op + 'EventListener'].call(target, ev, cb))\r\n    }\r\n\r\n    // Pass EventTarget interface calls to DOM EventTarget object\r\n    return {\r\n        // unbinds all events\r\n        removeAllCustomListeners(){\r\n            Object.entries(callbacksPerType).forEach(([ev, cbArr]) => {\r\n                cbArr.forEach(cb => addRemove('remove', ev, cb))\r\n            })\r\n\r\n            callbacksPerType = {}\r\n        },\r\n\r\n        off(events, cb){\r\n            if( events ) {\r\n                if( cb )\r\n                    addRemove('remove', events, cb)\r\n                else\r\n                    // if `cb` argument was not specified then remove all listeners for the given event(s) types\r\n                    events.split(/\\s+/g).forEach(ev => {\r\n                        callbacksPerType[ev]?.forEach(cb => addRemove('remove', ev, cb))\r\n                        delete callbacksPerType[ev]\r\n                    })\r\n            }\r\n\r\n            return this\r\n        },\r\n\r\n        on(events, cb){\r\n            if(cb && typeof cb == 'function') {\r\n                //track events callbacks to be able to remove them altogehter\r\n                events.split(/\\s+/g).forEach(ev => {\r\n                    if (Array.isArray(callbacksPerType[ev]) )\r\n                        callbacksPerType[ev].push(cb)\r\n                    else\r\n                        callbacksPerType[ev] = [cb]\r\n                })\r\n\r\n                addRemove('add', events, cb)\r\n            }\r\n\r\n            return this\r\n        },\r\n\r\n        trigger(eventName, data, opts){\r\n            var e;\r\n\r\n            opts = opts || {\r\n                cloneData:true\r\n            }\r\n\r\n            if( !eventName ) return;\r\n\r\n            if( instance.settings.isJQueryPlugin ){\r\n                if( eventName == 'remove' ) eventName = 'removeTag' // issue #222\r\n                jQuery(instance.DOM.originalInput).triggerHandler(eventName, [data])\r\n            }\r\n            else{\r\n                try {\r\n                    var eventData = typeof data === 'object'\r\n                        ? data\r\n                        : {value:data};\r\n\r\n                    eventData = opts.cloneData ? extend({}, eventData) : eventData\r\n                    eventData.tagify = this\r\n\r\n                    if( data.event )\r\n                        eventData.event = this.cloneEvent(data.event)\r\n\r\n                    // TODO: move the below to the \"extend\" function\r\n                    if( data instanceof Object )\r\n                        for( var prop in data )\r\n                            if(data[prop] instanceof HTMLElement)\r\n                                eventData[prop] = data[prop]\r\n\r\n                    e = new CustomEvent(eventName, {\"detail\":eventData})\r\n                }\r\n                catch(err){ logger.warn(err) }\r\n\r\n                target.dispatchEvent(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["ZERO_WIDTH_UNICODE_CHAR", "t", "e", "i", "n", "logger", "isEnabled", "window", "TAGIFY_DEBUG", "log", "_len", "arguments", "length", "args", "Array", "_key", "console", "this", "_to_consumable_array", "warn", "sameStr", "s1", "s2", "caseSensitive", "trim", "toLowerCase", "removeCollectionProp", "collection", "unwantedProps", "isArray", "map", "v", "omit", "obj", "props", "p", "newObj", "indexOf", "parseHTML", "s", "DOMParser", "parseFromString", "body", "firstElementChild", "getfirstTextNode", "elm", "action", "nodeType", "escapeHTML", "replace", "isObject", "type", "Object", "prototype", "toString", "call", "split", "slice", "extend", "o", "o1", "o2", "copy", "a", "b", "key", "hasOwnProperty", "assign", "concatWithoutDups", "newArr", "existingObj", "_iteratorNormalCompletion", "_didIteratorError", "_iteratorError", "undefined", "_step", "_iterator", "Symbol", "iterator", "arr", "value", "_iteratorNormalCompletion1", "_didIteratorError1", "_iteratorError1", "_step1", "_iterator1", "item", "push", "includes", "err", "return", "unaccent", "String", "normalize", "isChromeAndroidBrowser", "test", "navigator", "userAgent", "getUID", "c", "crypto", "getRandomValues", "Uint8Array", "isNodeTag", "node", "isNodeBelongsToThisTagifyInstance", "classList", "contains", "settings", "classNames", "tag", "isWithinNodeTag", "closest", "tagSelector", "namespaceSelector", "DOM", "scope", "injectAtCaret", "content", "range", "selection", "getSelection", "getRangeAt", "document", "createTextNode", "deleteContents", "insertNode", "getSetTagData", "tagElm", "data", "override", "__tagifyTagData", "placeCaretAfterNode", "parentNode", "nextSibling", "sel", "rangeCount", "setStartAfter", "collapse", "removeAllRanges", "addRange", "fixCaretBetweenTags", "tags", "TagifyHasFocuse", "forEach", "previousSibling", "textNode", "before", "DEFAULTS", "delimiters", "pattern", "tagTextProp", "maxTags", "Infinity", "callbacks", "addTagOnBlur", "addTagOn", "onChangeAfterBlur", "duplicates", "whitelist", "blacklist", "enforceWhitelist", "userInput", "focusable", "keepInvalidTags", "createInvalidTags", "mixTagsAllowedAfter", "mixTagsInterpolator", "backspace", "skipInvalid", "pasteAsTags", "editTags", "clicks", "keepInvalid", "transformTag", "a11y", "focusableTags", "mixMode", "insertAfterTag", "autoComplete", "enabled", "rightKey", "tabKey", "namespace", "selectMode", "input", "focus", "tagNoAnimation", "tagInvalid", "tagNotAllowed", "scopeLoading", "hasMaxTags", "hasNoTags", "empty", "inputInvalid", "dropdown", "dropdownWrapper", "dropdownHeader", "dropdownFooter", "dropdownItem", "dropdownItemActive", "dropdownItemHidden", "dropdownItemSelected", "dropdownInital", "tagText", "tagX", "tagLoading", "tagEditing", "tagFlash", "tagHide", "classname", "maxItems", "searchKeys", "fuzzySearch", "accentedSearch", "includeSelectedTags", "highlightFirst", "closeOnSelect", "clearOnSelect", "position", "appendTarget", "hooks", "beforeRemoveTag", "Promise", "resolve", "beforePaste", "suggestionClick", "beforeKeyDown", "initDropdown", "_dropdown", "bind", "refs", "__tagify", "_object_spread_props", "suggestionsMethods", "events", "binding", "bindUnbind", "_CB", "_CBR", "listeners", "onKeyDown", "onMouseOver", "onMouseLeave", "onClick", "onScroll", "state", "hasFocus", "composing", "_s", "selectedElm", "querySelector", "dropdownItemActiveSelector", "selectedElmData", "getSuggestionDataByNode", "isMixMode", "mode", "isSelectMode", "tagify", "then", "result", "preventDefault", "dropdownItems", "_this", "getAllSuggestionsRefs", "actionUp", "getNextOrPrevOption", "matches", "dropdownItemSelector", "highlightOption", "itemsPerPage", "Math", "floor", "clientHeight", "offsetHeight", "isPageUp", "currentIndex", "targetIndex", "max", "min", "hide", "actions", "ArrowLeft", "shouldAutocompleteOnKey", "editing", "getMappedValue", "autoCompleteData", "autocomplete", "set", "selectOption", "setTimeout", "tagData", "suggestionElm", "addTags", "inputText", "catch", "raw", "charCodeAt", "removeTags", "editTag", "ddItem", "target", "button", "pos", "scrollTop", "scrollHeight", "trigger", "percentage", "round", "refilter", "query", "suggestedListItems", "filterListItems", "fill", "getAttribute", "selected", "next", "selectedIdx", "findIndex", "adjustScroll", "itemData", "className", "ddItemElm", "remove", "removeAttribute", "ddItemData", "suggest", "add", "setAttribute", "offsetTop", "event", "isNoMatch", "find", "normalizedTagData", "normalizeTags", "onEditTagDone", "__isValid", "toggleFocusClass", "addEventListener", "fillHeaderFooter", "once", "selectAll", "onlyRendered", "tagsToAdd", "suggestions", "options", "whitelistItem", "valueIsInWhitelist", "searchBy", "isDuplicate", "niddle", "l", "startsWithMatch", "exactMatch", "_searchKeys", "keys", "some", "k", "_sd", "exact", "reduce", "values", "every", "q", "isTagDuplicate", "exactMatchesList", "sortby", "list", "unshift", "d", "suggestionsCount", "hasCustomSort", "filter", "_this1", "filteredList", "concat", "mapValueTo", "createListHTML", "sugegstionsList", "suggestion", "idx", "mappedValue", "templates", "apply", "join", "parseTemplate", "getHeaderRef", "getFooterRef", "querySelectorAll", "show", "firstListItem", "firstListItemValue", "noMatchListItem", "allowNewTags", "noWhitelist", "isManual", "dropdownItemNoMatch", "isLoading", "readonly", "clearTimeout", "dropdownHide__bindEventsTimeout", "visible", "setStateSelection", "render", "overrideManual", "_this_DOM", "removeEventListener", "removeChild", "flaggedTags", "baseOffset", "toggle", "getAppendTarget", "height", "clone", "ddHeight", "cloneNode", "style", "cssText", "appendChild", "HTMLContent", "dropdownContent", "innerHTML", "newHeaderElem", "newFooterElem", "headerRef", "footerRef", "replaceChild", "rect", "top", "bottom", "left", "width", "ancestorsOffsets", "isPlacedAbove", "cssTop", "cssLeft", "ddElm", "isRTL", "RTL", "isDefaultAppendTarget", "isSelfAppended", "appendTargetScrollTop", "pageYOffset", "root", "fullscreenElement", "webkitFullscreenElement", "documentElement", "viewportHeight", "positionTo", "clientWidth", "innerWidth", "ddTarget", "r2", "r", "startContainer", "offset", "startOffset", "createRange", "setStart", "setEnd", "getBoundingClientRect", "right", "getCaretGlobalPosition", "offsetLeft", "accumulatedAncestorsScrollTop", "ceil", "placeAbove", "pageXOffset", "STORE_KEY", "TEXTS", "exceed", "duplicate", "notAllowed", "wrapper", "disabled", "required", "placeholder", "param", "title", "class", "getAttributes", "_t", "hasMore", "customBinding", "customEventsList", "name", "on", "mainEvents", "eventName", "main", "bindGlobal", "isJQueryPlugin", "jQuery", "originalInput", "removeAllTags", "keydown", "onKeydown", "click", "onClickScope", "dblclick", "onDoubleClickScope", "paste", "onPaste", "drop", "onDrop", "compositionstart", "onCompositionStart", "compositionend", "onCompositionEnd", "inputMutationObserver", "MutationObserver", "onInputDOMChange", "disconnect", "observe", "childList", "bindOriginaInputListener", "delay", "DELAY", "clearInterval", "originalInputValueObserverInterval", "setInterval", "observeOriginalInputValue", "unbind", "global", "isIE", "cb", "onWindowKeyDown", "onFocusBlur", "onClickAnywhere", "useCapture", "unbindGlobal", "_this_value_", "_this_value", "nodeTag", "relatedTarget", "targetIsTagNode", "isTargetXBtn", "isFocused", "lostFocus", "Date", "text", "textContent", "currentDisplayValue", "ddEnabled", "eventData", "isTargetSelectOption", "isTargetAddNewBtn", "addNew", "postUpdate", "triggerChangeEvent", "dropdownCanBeShown", "condition2", "loading", "firstTagNode", "getTagElms", "nextTag", "focusedElm", "activeElement", "isBelong", "isInputNode", "isReadyOnlyTag", "hasAttribute", "nextElementSibling", "targetIsRemoveBtn", "deleteKeyTagDetected", "anchorOffset", "anchorNode", "prevAnchorSibling", "isCaretAfterTag", "el", "createElement", "enc", "innerText", "lastTagElems", "tagBeforeCaret", "tagElmToBeDeleted", "firstTextNodeBeforeTag", "isZWS", "nodeValue", "fromCharCode", "previousElementSibling", "_instanceof", "Element", "nodeName", "isManualDropdown", "blur", "inputSuggestion", "thingToAdd", "onInput", "onMixTagsInput", "showSuggestions", "inputElm", "validation", "validateTag", "toggleScopeValidation", "isValid", "search", "rangeText", "match", "matchedPatternCount", "matchFlaggedTag", "matchDelimiters", "lastTagsCount", "tagsElems", "fragment", "createDocumentFragment", "remainingTagsValues", "inputType", "createTagElem", "childNodes", "setRangeAtStartEnd", "lastChild", "update", "withoutChangeEvent", "cloneRange", "focusNode", "endOffset", "lastIndexOf", "prefix", "onInputIE", "destroy", "tagifyValue", "loadOriginalValues", "closestTagifyDropdownElem", "dropdownSelector", "isScope", "timeDiffFocus", "index", "getNodeIndex", "fixFirefoxLastTagNoCaret", "clipboardData", "pastedText", "getData", "onEditTagInput", "editableElm", "_obj", "tagElmIdx", "textValue", "dataForChangedProp", "_define_property", "__tagId", "editTagChangeDetected", "originalIsValid", "newValue", "onEditTagPaste", "newNode", "onEditTagClick", "onEditTagFocus", "onEditTagBlur", "isRelatedTargetNodeTag", "newTagData", "originalData", "__originalData", "hasChanged", "_obj1", "message", "onEditTagkeydown", "__originalHTML", "EDITED_TAG_BLUR_DELAY", "isEditingTag", "editable", "m", "record", "addedNodes", "addedNode", "outerHTML", "replaceWith", "newlineText", "nextNode", "anythingAfterNode", "removedNodes", "removedNode", "lastInputChild", "Tagify", "mockInstance", "Proxy", "get", "id", "instance", "callbacksPerType", "addRemove", "op", "ev", "removeAllCustomListeners", "entries", "cbArr", "off", "opts", "cloneData", "triggerHandler", "cloneEvent", "prop", "HTMLElement", "CustomEvent", "detail", "dispatchEvent", "isFirefox", "documentMode", "getPersistedData", "localStorage", "persistedData", "customKey", "getItem", "JSON", "parse", "setPersistedData", "setItem", "stringify", "Event", "clearPersistedData", "base", "removeItem", "applySettings", "build", "getCSSVars", "autofocus", "helpers", "dataProps", "template", "setContentEditable", "generateClassSelectors", "currentName", "defineProperty", "mergedDefaults", "attrVal", "RegExp", "_delimiters", "_object_spread", "texts", "persistedWhitelist", "attrs", "getCustomAttributes", "propName", "output", "compStyle", "getComputedStyle", "CSSVars", "tagHideTransition", "unit", "pop", "getPropertyValue", "labelWrapper", "integrated", "originalInput_tabIndex", "tabIndex", "inputSelector", "insertBefore", "_this_DOM_scope_parentNode", "blockChangeEvent", "persistedOriginalValue", "parseMixTags", "tagName", "insertAdjacentHTML", "lastOriginalValueReported", "clonedEvent", "toggleClass", "force", "setPlaceholder", "str", "changed", "bubbles", "simulated", "_valueTracker", "setValue", "random", "start", "getTagTextNode", "tagTextSelector", "setTagTextNode", "HTML", "getLastTag", "tagIdx", "skipValidation", "editTagToggleValidity", "removeTagsFromValue", "previousData", "replaceTag", "reCheckInvalidTags", "getInvalidTagAttrs", "newTagElm", "updateValueByDOMTags", "clsNames", "skipNodesWithClassNames", "cls", "injectedNode", "_this_state_selection", "appendMixTags", "updateDOM", "hideDropdown", "validate", "source", "charAt", "suggestedText", "suggestionStart", "substr", "suggestionTrimmed", "substring", "dataSuggest", "replaceTextWithNode", "getTagIdx", "classess", "_sc", "tagNodes", "tagId", "dupsCount", "done", "getTagIndexByValue", "indices", "isCaseSensitive", "getTagElmByValue", "flashTag", "isTagBlacklisted", "x", "isTagWhitelisted", "getWhitelistItem", "_wi", "_wiv", "setReadonly", "attrribute", "contentEditable", "setDisabled", "isDisabled", "tagsItems", "_this_settings", "whitelistMatches", "whitelistWithProps", "isCollection", "mapStringToCollection", "acc", "trimmed", "itemCopy", "whitelistMatchesValues", "filteredItem", "matchObj", "tagsDataSet", "textProp", "preInterpolated", "maxTagsReached", "Error", "newWrapperNode", "strToReplace", "nodeToReplace", "nodeAtCaret", "firstSplitOffset", "splitText", "prepareNewTagNode", "aggregatedInvalidInput", "tagElmParams", "__preInvalidData", "postProcessNewTagNode", "selectTag", "lastTagElm", "appendTag", "addEmptyTag", "initialData", "clearInput", "tagElems", "frag", "addedTags", "addMixTags", "newTagNode", "tagsData", "prefixedTextToTag", "children", "_this_state_tag", "newTag", "createdFromDelimiters", "insertBeforeNode", "extraData", "templateData", "textnode", "iter", "createNodeIterator", "NodeFilter", "SHOW_TEXT", "tagValidation", "tagElms", "silent", "tranDuration", "tagsToRemove", "elms", "__removed", "removeNode", "parseFloat", "clientTop", "reason", "removeTagsFromDOM", "splice", "hasValue", "setOriginalInputValue", "debouncedUpdateTimeout", "inputValue", "getInputValue", "getCleanValue", "getMixedTagsAsString", "originalInputValueFormat", "that", "_interpolator", "iterateChildren", "rootNode", "removeTag"]
}
