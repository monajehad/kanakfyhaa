{
  "version": 3,
  "sources": ["../../jquery-idletimer/src/idle-timer.js"],
  "sourcesContent": ["/*\n * Copyright (c) 2009 Nicholas C. Zakas\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sub-license, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n/*\n\tmousewheel (deprecated) -> IE6.0, Chrome, Opera, Safari\n\tDOMMouseScroll (deprecated) -> Firefox 1.0\n\twheel (standard) -> Chrome 31, Firefox 17, IE9, Firefox Mobile 17.0\n\n\t//No need to use, use DOMMouseScroll\n\tMozMousePixelScroll -> Firefox 3.5, Firefox Mobile 1.0\n\n\t//Events\n\tWheelEvent -> see wheel\n\tMouseWheelEvent -> see mousewheel\n\tMouseScrollEvent -> Firefox 3.5, Firefox Mobile 1.0\n*/\n(function ($) {\n\n    $.idleTimer = function (firstParam, elem, uniqueId) {\n        var opts;\n        if ( typeof firstParam === \"object\" ) {\n            opts = firstParam;\n            firstParam = null;\n        } else if (typeof firstParam === \"number\") {\n            opts = { timeout: firstParam };\n            firstParam = null;\n        }\n\n        // element to watch\n        elem = elem || document;\n\n        uniqueId = uniqueId || \"\";\n\n        // defaults that are to be stored as instance props on the elem\n        opts = $.extend({\n            idle: false,                // indicates if the user is idle\n            timeout: 30000,             // the amount of time (ms) before the user is considered idle\n            events: \"mousemove keydown wheel DOMMouseScroll mousewheel mousedown touchstart touchmove MSPointerDown MSPointerMove\" // define active events\n        }, opts);\n\n        var jqElem = $(elem),\n            obj = jqElem.data(\"idleTimerObj\" + uniqueId) || {},\n\n            /* (intentionally not documented)\n             * Toggles the idle state and fires an appropriate event.\n             * @return {void}\n             */\n            toggleIdleState = function (e) {\n                var obj = $.data(elem, \"idleTimerObj\" + uniqueId) || {};\n\n                // toggle the state\n                obj.idle = !obj.idle;\n\n                // store toggle state date time\n                obj.olddate = +new Date();\n\n                // create a custom event, with state and name space\n                var event = $.Event((obj.idle ? \"idle\" : \"active\") + \".idleTimer\" + uniqueId);\n\n                // trigger event on object with elem and copy of obj\n                $(elem).trigger(event, [elem, $.extend({}, obj), e]);\n            },\n            /**\n             * Handle event triggers\n             * @return {void}\n             * @method event\n             * @static\n             */\n            handleEvent = function (e) {\n\n                var obj = $.data(elem, \"idleTimerObj\" + uniqueId) || {};\n                \n\t\t            // ignore writting to storage unless related to idleTimer\n                if (e.type === \"storage\" && e.originalEvent.key !== obj.timerSyncId) {\n                    return;\n                }\n\n                // this is already paused, ignore events for now\n                if (obj.remaining != null) { return; }\n\n                /*\n                mousemove is kinda buggy, it can be triggered when it should be idle.\n                Typically is happening between 115 - 150 milliseconds after idle triggered.\n                @psyafter & @kaellis report \"always triggered if using modal (jQuery ui, with overlay)\"\n                @thorst has similar issues on ios7 \"after $.scrollTop() on text area\"\n                */\n                if (e.type === \"mousemove\") {\n                    // if coord are same, it didn't move\n                    if (e.pageX === obj.pageX && e.pageY === obj.pageY) {\n                        return;\n                    }\n                    // if coord don't exist how could it move\n                    if (typeof e.pageX === \"undefined\" && typeof e.pageY === \"undefined\") {\n                        return;\n                    }\n                    // under 200 ms is hard to do, and you would have to stop, as continuous activity will bypass this\n                    var elapsed = (+new Date()) - obj.olddate;\n                    if (elapsed < 200) {\n                        return;\n                    }\n                }\n\n                // clear any existing timeout\n                clearTimeout(obj.tId);\n\n                // if the idle timer is enabled, flip\n                if (obj.idle) {\n                    toggleIdleState(e);\n                }\n\n                // store when user was last active\n                obj.lastActive = +new Date();\n\n                // update mouse coord\n                obj.pageX = e.pageX;\n                obj.pageY = e.pageY;\n\n                // sync lastActive\n                if (e.type !== \"storage\" && obj.timerSyncId) {\n                  if (typeof(localStorage) !== \"undefined\") {\n                    localStorage.setItem(obj.timerSyncId, obj.lastActive);\n                  }\n                }\n\n                // set a new timeout\n                obj.tId = setTimeout(toggleIdleState, obj.timeout);\n            },\n            /**\n             * Restore initial settings and restart timer\n             * @return {void}\n             * @method reset\n             * @static\n             */\n            reset = function () {\n\n                var obj = $.data(elem, \"idleTimerObj\" + uniqueId) || {};\n\n                // reset settings\n                obj.idle = obj.idleBackup;\n                obj.olddate = +new Date();\n                obj.lastActive = obj.olddate;\n                obj.remaining = null;\n\n                // reset Timers\n                clearTimeout(obj.tId);\n                if (!obj.idle) {\n                    obj.tId = setTimeout(toggleIdleState, obj.timeout);\n                }\n\n            },\n            /**\n             * Store remaining time, stop timer\n             * You can pause from an idle OR active state\n             * @return {void}\n             * @method pause\n             * @static\n             */\n            pause = function () {\n\n                var obj = $.data(elem, \"idleTimerObj\" + uniqueId) || {};\n\n                // this is already paused\n                if ( obj.remaining != null ) { return; }\n\n                // define how much is left on the timer\n                obj.remaining = obj.timeout - ((+new Date()) - obj.olddate);\n\n                // clear any existing timeout\n                clearTimeout(obj.tId);\n            },\n            /**\n             * Start timer with remaining value\n             * @return {void}\n             * @method resume\n             * @static\n             */\n            resume = function () {\n\n                var obj = $.data(elem, \"idleTimerObj\" + uniqueId) || {};\n\n                // this isn't paused yet\n                if ( obj.remaining == null ) { return; }\n\n                // start timer\n                if ( !obj.idle ) {\n                    obj.tId = setTimeout(toggleIdleState, obj.remaining);\n                }\n\n                // clear remaining\n                obj.remaining = null;\n            },\n            /**\n             * Stops the idle timer. This removes appropriate event handlers\n             * and cancels any pending timeouts.\n             * @return {void}\n             * @method destroy\n             * @static\n             */\n            destroy = function () {\n\n                var obj = $.data(elem, \"idleTimerObj\" + uniqueId) || {};\n\n                //clear any pending timeouts\n                clearTimeout(obj.tId);\n\n                //Remove data\n                jqElem.removeData(\"idleTimerObj\" + uniqueId);\n\n                //detach the event handlers\n                jqElem.off(\"._idleTimer\" + uniqueId);\n            },\n            /**\n            * Returns the time until becoming idle\n            * @return {number}\n            * @method remainingtime\n            * @static\n            */\n            remainingtime = function () {\n\n                var obj = $.data(elem, \"idleTimerObj\" + uniqueId) || {};\n\n                //If idle there is no time remaining\n                if ( obj.idle ) { return 0; }\n\n                //If its paused just return that\n                if ( obj.remaining != null ) { return obj.remaining; }\n\n                //Determine remaining, if negative idle didn't finish flipping, just return 0\n                var remaining = obj.timeout - ((+new Date()) - obj.lastActive);\n                if (remaining < 0) { remaining = 0; }\n\n                //If this is paused return that number, else return current remaining\n                return remaining;\n            };\n\n\n        // determine which function to call\n        if (firstParam === null && typeof obj.idle !== \"undefined\") {\n            // they think they want to init, but it already is, just reset\n            reset();\n            return jqElem;\n        } else if (firstParam === null) {\n            // they want to init\n        } else if (firstParam !== null && typeof obj.idle === \"undefined\") {\n            // they want to do something, but it isnt init\n            // not sure the best way to handle this\n            return false;\n        } else if (firstParam === \"destroy\") {\n            destroy();\n            return jqElem;\n        } else if (firstParam === \"pause\") {\n            pause();\n            return jqElem;\n        } else if (firstParam === \"resume\") {\n            resume();\n            return jqElem;\n        } else if (firstParam === \"reset\") {\n            reset();\n            return jqElem;\n        } else if (firstParam === \"getRemainingTime\") {\n            return remainingtime();\n        } else if (firstParam === \"getElapsedTime\") {\n            return (+new Date()) - obj.olddate;\n        } else if (firstParam === \"getLastActiveTime\") {\n            return obj.lastActive;\n        } else if (firstParam === \"isIdle\") {\n            return obj.idle;\n        }\n\n\t// Test via a getter in the options object to see if the passive property is accessed\n\t// This isnt working in jquery, though is planned for 4.0\n\t// https://github.com/jquery/jquery/issues/2871\n        /*var supportsPassive = false;\n        try {\n            var Popts = Object.defineProperty({}, \"passive\", {\n                get: function() {\n                    supportsPassive = true;\n                }\n            });\n            window.addEventListener(\"test\", null, Popts);\n        } catch (e) {}\n\t*/\n\n        /* (intentionally not documented)\n         * Handles a user event indicating that the user isn't idle. namespaced with internal idleTimer\n         * @param {Event} event A DOM2-normalized event object.\n         * @return {void}\n         */\n        jqElem.on((opts.events + \" \").split(\" \").join(\"._idleTimer\" + uniqueId + \" \").trim(), function (e) {\n\n            handleEvent(e);\n        });\n        //}, supportsPassive ? { passive: true } : false);\n\n        if (opts.timerSyncId) {\n            $(window).on(\"storage\", handleEvent);\n        }\n\n        // Internal Object Properties, This isn't all necessary, but we\n        // explicitly define all keys here so we know what we are working with\n        obj = $.extend({}, {\n            olddate : +new Date(),          // the last time state changed\n            lastActive: +new Date(),       // the last time timer was active\n            idle : opts.idle,               // current state\n            idleBackup : opts.idle,         // backup of idle parameter since it gets modified\n            timeout : opts.timeout,         // the interval to change state\n            remaining : null,               // how long until state changes\n            timerSyncId : opts.timerSyncId, // localStorage key to use for syncing this timer\n            tId : null,                     // the idle timer setTimeout\n            pageX : null,                   // used to store the mouse coord\n            pageY : null\n        });\n\n        // set a timeout to toggle state. May wish to omit this in some situations\n        if (!obj.idle) {\n            obj.tId = setTimeout(toggleIdleState, obj.timeout);\n        }\n\n        // store our instance on the object\n        $.data(elem, \"idleTimerObj\" + uniqueId, obj);\n\n        return jqElem;\n    };\n\n    // This allows binding to element\n    $.fn.idleTimer = function (firstParam, uniqueId) {\n        if (this[0]) {\n            return $.idleTimer(firstParam, this[0], uniqueId);\n        }\n\n        return this;\n    };\n\n})(jQuery);\n"],
  "mappings": "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",
  "names": ["obj"]
}
